# coding:utf-8
# usr/bin/python3
# python src/chapter26/chapter26note.py
# python3 src/chapter26/chapter26note.py
'''

Class Chapter26_1

Class Chapter26_2

Class Chapter26_3

Class Chapter26_4

Class Chapter26_5

'''
from __future__ import absolute_import, division, print_function

import math as _math
import random as _random
import time as _time
from copy import copy as _copy
from copy import deepcopy as _deepcopy
from random import randint as _randint

import numpy as np
from numpy import arange as _arange
from numpy import array as _array

if __name__ == '__main__':
    import flownetwork as _fn
else:
    from . import flownetwork as _fn

class Chapter26_1:
    '''
    chpater26.1 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.1 note

        Example
        ====
        ```python
        Chapter26_1().note()
        ```
        '''
        print('chapter26.1 note as follow')  
        print('第26章 最大流')
        print('为了求从一点到另一点的最短路径，可以把公路地图模型化为有向图')
        print('可以把一个有向图理解为一个流网络,并运用它来回答有关物流方面的问题')
        print('设想某物质从产生它的源点经过一个系统,流向消耗该物质的汇点(sink)这样一种过程')
        print('源点以固定速度产生该物质,而汇点则用同样的速度消耗该物质.',
            '从直观上看,系统中任何一点的物质的流为该物质在系统中运行的速度')
        print('物质进入某顶点的速度必须等于离开该顶点的速度,流守恒性质,',
            '当物质是电流时,流守恒与基尔霍夫电流定律等价')
        print('最大流问题是关于流网络的最简单的问题')
        print('26.1 流网络')
        print('流网络的流')
        print('  流网络G=(V,E)是一个有向图,其中每条边(u,v)∈E均有一非负容量c(u,v)>=0',
            '如果(u,v)∉E,则假定c(u,v)=0。流网络中有两个特别的顶点：源点s和汇点t',
            '为了方便起见，假定每个顶点均处于从源点到汇点的某条路径上，就是说,每个顶点v∈V,存在一条路径s->v->t',
            '因此,图G为连通图,且|E|>=|V|-1')
        print('流的定义')
        print('  设G=(V,E)是一个流网络,其容量函数为c。设s为网络的源点，t为汇点。',
            'G的流是一个实值函数f:V*V->R,且满足下列三个性质：')
        print('  (1) 容量限制：对所有u,v∈V,要求f(u,v)<=c(u,v)')
        print('  (2) 反对称性：对所有u,v∈V,要求f(u,v)=-f(v,u)')
        print('  (3) 流守恒性：对所有u∈V-{s,t},要求∑f(u,v)=0')
        print('  f(u,v)称为从顶点u到顶点v的流，可以为正，为零，也可以为负。流f的值定义为|f|=∑f(s,v)',
            '即从源点出发的总流.在最大流问题中,给出一个具有源点s和汇点t的流网络G,希望找出从s到t的最大值流')
        print('容量限制只说明从一个顶点到另一个顶点的网络流不能超过设定的容量',
            '反对称性说明从顶点u到顶点v的流是其反向流求负所得.',
            '流守恒性说明从非源点或非汇点的顶点出发的总网络流为0')
        print('定义某个顶点处的总的净流量(total net flow)为离开该顶点的总的正能量,减去进入该顶点的总的正能量')
        print('流守恒性的一种解释是这样的,即进入某个非源点非汇点顶点的正网络流，必须等于离开该顶点的正网络流',
            '这个性质(即一个顶点处的总的净流量必定为0)常常被形式化地称为\"流进等于流出\"')
        print('通常，利用抵消处理，可以将两城市间的运输用一个流来表示,该流在两个顶点之间的至多一条边上是正的')
        print('给定一个实际运输的网络流f,不能重构其准确的运输路线,如果知道f(u,v)=5,',
            '如果知道f(u,v)=5,表示有5个单位从u运输到了v,或者表示从u到v运输了8个单位,v到u运输了3个单位')
        print('本章的算法将隐式地利用抵消,假设边(u,v)有流量f(u,v).在一个算法的过程中,可能对边(u,v)上的流量增加d',
            '在数学上,这一操作为f(u,v)减d；从概念上看,可以认为这d个单位是对边(u,v)上d个单位流量的抵消')
        print('具有多个源点和多个汇点的网络')
        print('  在一个最大流问题中,可以有几个源点和几个汇点,而非仅有一个源点和一个汇点',
            '比如物流公司实际可能拥有m个工厂{s1,s2,...,sm}和n个仓库{t1,t2,...,tn}',
            '这个问题不比普通的最大流问题更难')
        print('  在具有多个源点和多个汇点的网络中,确定最大流的问题可以归约为一个普通的最大流问题',
            '通过增加一个超级源点s,并且对每个i=1,2,...,m加入有向边(s,si),其容量c(s,si)=∞',
            '同时创建一个超级汇点t,并且对每个j=1,2,...,n加入有向边(tj,t),其容量c(tj,t)=∞')
        print('  单源点s对多个源点si提供了其所需要的任意大的流.同样,单汇点t对多个汇点tj消耗其所需要的任意大的流')
        print('对流的处理')
        print('  下面来看一些函数(如f),它们以流网络中的两个顶点作为自变量',
            '在本章,将使用一种隐含求和记号,其中任何一个自变量或两个自变量可以是顶点的集合',
            '它们所表示的值是对自变量所代表元素的所有可能的情形求和')
        print('  流守恒限制可以表述为对所有u∈V-{s,t},有f(u,V)=0,',
            '同时,为方便起见,在运用隐含求和记法时,省略集合的大括号.例如,在等式f(s,V-s)=f(s,V)中',
            '项V-s是指集合V-{s}')
        print('隐含集合记号常可以简化有关流的等式.下列引理给出了有关流和隐含记号的几个恒等式')
        print('引理26.1 设G=(V,E)是一个流网络,f是G中的一个流.那么下列等式成立')
        print(' 1) 对所有X∈V,f(X,X)=0')
        print(' 2) 对所有X,Y∈V,f(X,Y)=-f(Y,X)')
        print(' 3) 对所有X,Y,Z∈V,其中X∧Y!=None,有f(X∨Y,Z)=f(X,Y)+f(Y,Z)且f(Z,X∨Y)=f(Z,X)+f(Z,Y)')
        print('作为应用隐含求和记法的一个例子,可以证明一个流的值为进入汇点的全部网络流,即|f|=f(V,t)')
        print('根据流守恒特性,除了源点和汇点以外,对所有顶点来说,进入顶点的总的正流量等于离开该顶点的总的正能量',
            '根据定义,源点顶点总的净流量大于0；亦即，对源点顶点来说，离开它的正流要比进入它的正流更多',
            '对称地，汇点顶点是唯一一个其总的净流量小于0的顶点;亦即,进入它的正流要比离开它的正流更多')
        print('练习26.1-1 利用流的定义，证明如果(u,v)∉E,且(v,u)∉E,有f(u,v)=f(v,u)=0')
        print('练习26.1-2 证明：对于任意非源点非汇点的顶点v,进入v的总正向流必定等于离开v的总正向流')
        print('练习26.1-3 证明在具有多个源点和多个汇点的流网络中,任意流均对应于通过增加一个超级源点',
            '和超级汇点所得到的具有相同值的一个单源点单汇点流')
        print('练习26.1-4 证明引理26.1')
        print('练习26.1-5 在所示的流网络G=(V,E)和流f,找出两个子集合X,Y∈V,且满足f(X,Y)=-f(V-X,Y)',
            '再找出两个子集合X,Y∈V,且满足f(X,Y)!=-f(V-X,Y)')
        print('练习26.1-6 给定流网络G=(V,E),设f1和f2为V*V到R上的函数.流的和f1+f2是从V*V到R上的函数',
            '定义如下：对所有u,v∈V (f1+f2)(u,v)=f1(u,v)+f2(u,v)',
            '如果f1和f2为G的流,则f1+f2必满足流的三条性质中的哪一条')
        print('练习26.1-7 设f为网络中的一个流,a为实数。标量流之积是一个从V*V到R上的函数,定义为(af)(u,v)=a*f(u,v)',
            '证明网络中的流形成一个凸集','即证明如果f1和f2是流,则对所有0<=a<=1,af1+(1-a)f2也是流')
        print('练习26.1-8 将最大流问题表述为一个线性规划问题')
        print('练习26.1-9 略')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_2:
    '''
    chpater26.2 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.2 note

        Example
        ====
        ```python
        Chapter26_2().note()
        ```
        '''
        print('chapter26.2 note as follow')  
        print('Ford-Fulkerson方法')
        print('解决最大流问题的Ford-Fulkerson方法,包含具有不同运行时间的几种实现')
        print('Ford-Fulkerson方法依赖于三种重要思想')
        print(' 残留网络,增广路径,割')
        print('这些思想是最大流最小割定理的精髓,该定理用流网络的割来描述最大流的值')
        print('Ford-Fulkerson方法是一种迭代方法.开始时,对所有u,v∈V,有f(u,v)=0,即初始状态时流的值为0',
            '在每次迭代中,可通过寻找一条\"增广路径\来增加流的值"。增广路径可以看作是从源点s到汇点t之间的一条路径',
            '沿该路径可以压入更多的流,从而增加流的值.反复进行这一过程,直至增广路径都被找出为止',
            '最大流最小割定理将说明在算法终止时,这一过程可产生出最大流')
        print('残留网络')
        print('  直观上,给定流网络和一个流,其残留网络由可以容纳更多网络流的边所组成',
            '更形式地,假定有一个网络G=(V,E),其源点为s,汇点到t.设f为G中的一个流,并考察一对顶点u,v∈V',
            '在不超过容量c(u,v)的条件下,从u到v之间可以压入的额外网络流量,就是(u,v)的残留容量(residual capacity),由下式定义:',
            'cf(u,v)=c(u,v)-f(u,v)')
        print('  例如,如果c(u,v)=16且f(u,v)=11,则在不超过边(u,v)的容量限制的条件下,可以再传输cf(u,v)=5个单位的流来增加f(u,v)',
            '当网络流f(u,v)为负值时,残留容量cf(u,v)大于容量c(u,v)')
        print('  例如,如果c(u,v)=16且f(u,v)-4,残留容量cf(u,v)为20')
        print('  解释：从v到u存在着4个单位的网络流,可以通过从u到v压入4个单位的网络来抵消它',
            '然后,在不超过边(u,v)的容量限制的条件下,还可以从u到v压入另外16个单位的网络流',
            '因此,从开始的网络流f(u,v)-4,共压入了额外的20个单位的网络流,并不会超过容量限制')
        print('  在残留网络中,每条边(或称为残留边)能够容纳一个严格为正的网络流')
        print('Ef中的边既可以是E中的边,也可以是它们的反向边',
            '如果边(u,v)∈E有f(u,v)<c(u,v),那么cf(u,v)=c(u,v)-f(u,v)>0且(u,v)属于Ef')
        print('只有当两条边(u,v)和(v,u)中,至少有一条边出现于初始网络中时,边(u,v)才能够出现在残留网络中,所以有如下限制条件:',
            '|Ef|<=2|E|.残留网络Gf本身也是一个流网络,其容量由cf给出.下列引理说明残留网络中的流与初始网络中的流有何关系')
        print('引理26.2 设G=(V,E)是源点为s,汇点为t的一个流网络,且f为G中的一个流',
            '设Gf是由f导出的G的残留网络,且f’为Gf中的一个流,其值|f+f`|=|f|+|f`|')
        print('增广路径')
        print('  已知一个流网络G=(V+E)和流f,增广路径p为残留网络Gf中从s到t的一条简单路径',
            '根据残留网络的定义,在不违反边的容量限制条件下,增广路径上的每条边(u,v)可以容纳从u到v的某额外正网络流')
        print('引理26.3 设G=(V,E)是一个网络流,f是G的一个流,并设p是Gf中的一条增广路径.',
            '用下式定义一个函数：fp：V*V->R')
        print('fp(u,v)=cf(p);fp(u,v)=-cf(p);fp(u,v)=0')
        print('则fp是Gf上的一个流,其值为|fp|=cf(p)>0')
        print('推论26.4 设G=(V,E)是一个流网络,f是G的一个流,p是Gf中的一条增广路径')
        print('流网络的割')
        print('  Ford-Fulkerson方法沿增广路径反复增加流,直至找出最大流为止.',
            '要证明的最大流最小割定理：一个流是最大流,当且仅当它的残留网络不包含增广路径')
        print('流网络G=(V,E)的割(S,T)将V划分成S和T=V-S两部分,使得s∈S,t∈T')
        print('一个网络的最小割也就是网络中所有割中具有最小容量的割')
        print('引理26.5 设f是源点s,汇点为t的流网络G中的一个流.并且(S,T)是G的一个割',
            '则通过割(S,T)的净流f(S,T)=|f|')
        print('推论26.6 对一个流网络G中任意流f来说,其值的上界为G的任意割的容量')
        print('定理26.7(最大流最小割定理) 如果f是具有源点s和汇点t的流网络G=(V,E)中的一个流,则下列条件是等价的:',
            '1) f是G的一个最大流')
        print('2) 残留网络Gf不包含增广路径')
        print('3) 对G的某个割(S,T),有|f|=c(S,T)')
        print('基本的Ford-Fulkerson算法')
        print('  在Ford-Fulkerson方法的每次迭代中,找出任意增广路径p,并把沿p每条边的流f加上其残留容量cf(p)',
            '在Ford-Fulkerson方法的以下实现中,',
            '通过更新有边相连的每对顶点u,v之间网络流f[u,v],来计算出图G=(V,E)中的最大流')
        print('如果u和v之间在任意方向没有边相连,则隐含地假设f[u,v]=0',
            '假定已经在图中给出,且如果(u,v)∉E,有c(u,v)=0.残留容量cf(u,v)',
            '代码中的符号cf(p)实际上只是存储路径p的残留容量的一个临时变量')
        print('Ford-Fulkerson算法的分析')
        print('  Ford-Fulkerson算法过程的运行时间取决于如何确定第4行中的增广路径,',
            '如果选择不好,算法甚至可能不会终止;流的值随着求和运算将不断增加,但它甚至不会收敛到流的最大值')
        print('  如果采用广度优先搜索来选择增广路径,算法的运行时间为多项式时间复杂度')
        print('  但是,在证明这一点之前,先任意选择增广路径、且所有容量均为整数,取得一个简单的界')
        print('在实际中碰到的大多数最大流的问题中其容量经常为整数,如果容量为有理数,则经过适当的比例转换,都可以使它们变为整数')
        print('在这一假设下,Ford-Fulkerson的一种简易实现的运行时间为O(E|f*|)')
        print('Edmonds-Karp算法')
        print('  如果在Ford-Fulkerson算法使用广度优先搜索来实现对增广路径p的计算',
            '即如果增广路径是残留网格中从s到t的最短路径(其中每条边为单位距离或权)',
            '则能够改进FORD-FULKERSON的界,这种方法称为Edmonds-Karp算法,运行时间为O(VE^2)')
        print('引理26.8 如果对具有源点s和汇点t的流网络G=(V,E)运行Edmonds-Karp算法,则对所有顶点v∈V-{s,t}',
            '残留网络Gf中的最短路径长度df(u,v)随着每个流的增加而单调递增')
        print('定理26.9 如果对具有源点s和汇点t的一个流网络G=(V,E)运行Edmonds-Karp算法,对流进行增加的全部次数为O(VE)')
        print('  在一个残留网络Gf中,如果对其增广路径p的残留容量是边(u,v)的残留容量,即,如果cf(p)=cf(u,v),则说边(u,v)对增广路径p是关键的',
            '在沿增广路径对流进行增加后,该路径上的任何关键边便从残留网络中消失')
        print('  在增广路径上至少有一条边必为关键边.|E|条边中的每一条都可能至多|V|/2-1次地成为关键边')
        print('用于在用广度优先搜索寻找增广路径时,FORD-FULKERSON中的每次迭代都可以在O(E)的运行时间内完成',
            '所以Edmonds-Karp算法的全部运行时间为O(V^2E).压入与重标记算法能够达到更好的界')
        print('练习26.2-1 斜杠左边表示流,右边表示容量;流是19,容量是')
        print('练习26.2-2 Edmonds-Karp算法的执行过程')
        _fn.test_edmonds_karp()
        print('练习26.2-3 在图26-5中,对应于图中最大流的最小割是多少',
            '在例中出现的增广路径中,哪两条路径抵消了先前被传输的流')
        print('练习26.2-4 证明对任意一对顶点u和v、任意的容量和流函数c和f,有:',
            'cf(u, v)+cf(v, u)=c(u,v)+c(v,u)')
        print('练习26.2-5 通过增加具有无限容量的边,把一个多源点多汇点的流网络转换为单源点单汇点的流网络',
            '证明:如果初始的多源点多汇点网络中的边具有有限的容量,则转换后所得的网络中的任意流均为有限值')
        print('练习26.2-6 假定在多源点多汇点问题中,每个源点si产生pi单位的流,即f(si,V)=pi.同时假定每个汇点tj消耗qj单位的流',
            '即f(V,ti)=qj,其中∑pi=∑pj,说明如何把寻找一个流f以满足这些附加限制的问题,转化为在一个单源点单汇点流网络中寻找最大流的问题')
        print('练习26.2-7 证明引理26.3')
        print('练习26.2-8 证明：一个网络G=(V,E)的最大流总可以被至多由|E|条增广路径所组成的序列发现(找出最大流后再确定路径)')
        print('练习26.2-9 无向图边连通度(edge connectivity)是指为了使图不连通而必须去掉的最少边数k',
            '例如,数的边连通度为1,顶点的循环链的边连通度是2,说明如何对至多|V|个流网络',
            '(每个流网络有O(V)个顶点和O(E)条边运行最大流算法),就可以确定无向图G=(V,E)的边连通度')
        print('练习26.2-10 假定一个流网络G=(V,E)中有对称边,也就是(u,v)∈E当且仅当(v,u)∈E',
            '试证明Edmonds-Karp算法在至多进行|V||E|/4次迭代后将终止执行',
            '(对任意边(u,v),考虑(u,v)为关键边的时刻之间,d(s,u)和d(v,t)是如何变化的)')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_3:
    '''
    chpater26.3 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.3 note

        Example
        ====
        ```python
        Chapter26_3().note()
        ```
        '''
        print('chapter26.3 note as follow')  
        print('26.3 最大二分匹配')
        print('一些组合问题可以很容易地转换为最大流问题.26.1节中的多源点,多汇点最大流问题就是一个例子')
        print('如在一个二分图中寻找最大匹配.为了解决这一问题,将利用Ford-Fulkerson方法提供的完整性性质')
        print('可以应用Ford-Fulkerson方法在O(VE)时间内解决图G=(V,E)的最大二分匹配问题')
        print('最大二分匹配问题')
        print('  给定一个无向图G=(V,E),一个匹配(matching)是一个边的子集合,且满足对所有的顶点v∈V,M中至多一条边与v关联',
            '如果M中某条边与v关联,则说顶点v∈V被匹配,否则说v是无匹配的.最大匹配是最大势的匹配,也就是说,是满足对任意匹配M`',
            '有|M|>=|M`|的匹配M')
        print('  假定顶点集合可被划分为V=L∨R,其中L和R是不相交的,且E中的所有边的一个端点在R中,另一端点在L中',
            '进一步假设V中的每个顶点至少有一条关联的边')
        print('  二分图的最大匹配问题有着许多世纪的应用.例如,把一个机器集合L和要同时执行的任务集合R相匹配。',
            'E中有边(u,v),就说明一台特定机器u∈L能够完成一项特定任务v∈R,最大匹配可以为尽可能多的机器提供任务')
        print('寻找最大二分匹配')
        print('  利用Ford-Fulkerson方法可以在关于|V|和|E|的多项式时间内,找出无向二分图G=(V,E)的最大匹配',
            '解决这一问题的关键技巧在于建立一个流网络,其中流对应于匹配')
        print('  对二分图G的相应流网络G`=(V`,E`)定义如下,设源点s和汇点t是不属于V的新顶点')
        print('V`=V∪{s,t}.如果G的顶点划分为V=L∪R,G`的有向边为E的边,从L指向R,再加上V条新边:')
        print('E`={(s,u):u∈L}∪{(u,v):u∈L,v∈R,(u,v)∈E}∪{(v,t):v∈R}')
        print('在结束构造工作之前,在E`中的每条边赋予单位容量.因为V中的每个顶点至少有一条关联边',
            '|E|>=|V|/2.因此|E|<=|E`|=|E|+|V|<=3|E|,则|E`|=Θ(E)')
        print('引理26.10 设G=(V,E)是一个二分图,其定点划分为V=L∪R,设G`=(V`,E`)是它相应的流网络',
            '如果M是G的匹配,则G`中存在一个整数值的流f,且|f|=|M|.',
            '相反地,如果f是G`的整数值流,则G中存在一匹配M满足|M|=|f|')
        print('在一个二分图G中,一个最大匹配对应于流网络G`中的一个最大流.因此,可以通过对G`运行最大流算法来计算出G的最大匹配',
            '这一推理过程中存在的唯一故障就是最大流算法可能返回一个G`的非整数量的流f(u,v),即使流的值|f|应该为一个整数')
        print('定理26.11(完整性定理)如果容量函数c只取整数值,则由Ford-Fulkerson方法得出的最大流f满足|f|为整数的性质',
            '此外,对所有顶点u和v,f(u,v)的值为整数')
        print('推论26.12 二分图G的一个最大匹配M的势是其相应的流网络G`中的某一最大流f的值')
        print('对于一个无向二分图G,可以利用下列方法找出其最大匹配:先建立流网络G`,对它进行Ford-Fulferson方法',
            '根据求得的具有整数值的最大流f,就可直接获得最大匹配M,因为二分图上的任何匹配的势至多为min(L,R)=O(V)',
            '所以G`中最大流的值为O(V),因此,可以在O(VE`)=O(VE)的时间内,找出一个二分图的最大匹配,因为|E`|=Θ(E)')
        print('练习26.3-1 对图26-8b中所示的流网络运行Ford-Fulkerson算法.并指出每次对流增加以后所得的残留网络,对L中的顶点从上到下编为1-5号,对R中的顶点从上到下编号为6-9号',
            '在每次迭代中,找出按辞典顺序排列时,最小的一条增广路径')
        print('练习26.3-2 证明定理26.11')
        print('练习26.3-3 设G=(V,E)为二分图,其定点划分为V=L∨R,且G`是其相应的流网络',
            '在Ford-Fulkerson执行过程中,对在G`中找出的任意增广路径的长度给出一个适当的上界')
        print('练习26.3-4 完全匹配(perfect matching)是指图中每个顶点均被匹配,设G=(V,E)是其定点分划为V=L∪R的一个无向二分图',
            '其中|L|=|R|.对任意X∈V,定义X的邻居为N(X)={y∈V,(x,y)∈E,对某个x∈X}',
            '即,由与X的某元素相邻的顶点所构成的集合.证明Hall定理：G中存在一个完全匹配,当且仅当对每个子集A∈L,有|A|<=|N(A)|')
        print('练习26.3-5 在二分图G=(V,E)中,V=L∪R,如果每个顶点v∈V的度均为d,则说该图是d正则的.每个d正则二分图有|L|=|R|',
            '证明:对每个d正则二分图,其相应流网络的最小割的容量为|L|.',
            '运用该结论证明:每个d正则二分图均有一个势为|L|的匹配')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_4:
    '''
    chpater26.4 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.4 note

        Example
        ====
        ```python
        Chapter26_4().note()
        ```
        '''
        print('chapter26.4 note as follow')  
        print('26.4 压入与重标记算法')
        print('目前许多关旭最大流问题的渐进最快速算法就是压入与重标记算法,',
            '最大流算法最快速的实际实现都是基于压入与重标记方法的')
        print('其他有关流的问题,如最小代价流问题,也可以有效地利用压入与重标记方法来解决')
        print('Goldberg的一般性最大流算法,该算法有一种简单的实现,其运行时间为O(V^2E),',
            '这是对Edmonds-Karp算法的O(VE^2)时间的一种改进,26.5节中对一般性算法进行进一步的精化',
            '得到另外一种运行时间为O(V^3)的压入与重标记算法')
        print('相对于Ford-Fulkerson方法来说,压入与重标记采用的是一种更局部化的方法',
            '它不是检查整个残留网络G=(V,E)来找出增广路径','而是每次仅对一个顶点进行操作',
            '并且仅检查残留网络中该顶点的相邻顶点')
        print('此外,与Ford-Fulkerson方法不同,压入与重标记算法在执行过程中,并不能保持流守恒特性')
        print('但是,该算法保持了一个前置流,它是一个函数f:V*V->R,他满足反对称性、容量限制和下列放宽条件的流守恒性特性',
            '对所有顶点u∈V-{s},有f(V,u)>=0.亦即,进入除源顶点以外的顶点的总净流为非负值.进入顶点u的总净流称为进入u的余流',
            '由下式给出e(u)=f(V,u),对一个顶点u∈V-{s,t},如果e(u)>0,则称顶点u溢出')
        print('压入与重标记方法所包含的直观思想')
        print('  把一个流网络G=(V,E)看成是具有给定容量、且互相连接的管道所组成的系统',
            '把这个比方应用到Ford-Fulkerson方法中,可以说网络中的每一条增广路径均引发一条无分支点',
            '从源点到汇点的额外液体流,Ford-Fulkerson方法以迭代的方式加入更多的流,直至不能加入时为止')
        print('  从直观上看,一般性压入与重标记算法的思想在某种程度上来说有所不同.和先前一样,图的有向边对应于管道',
            '而作为管道结合点的顶点却有着两个有趣的特性.第一，为了容纳余流,每个顶点均有一个排出管道',
            '它导向能积聚液体的任意大容量水库','每个顶点和它的水库以及所有的管道连接点都处于一个平台上,当算法向前压入时,平台随之逐渐升高')
        print('  顶点的高度决定了如何压入流:仅仅把流向下压,即从较高顶点向较低顶点压',
            '从较低顶点到较高顶点可能存在一正向网络流,但是对流的压入总是向下压',
            '源点的高度固定为|V|,汇点的高度固定为0.所有其他顶点的高度开始时都是零,并逐步增加')
        print('  最终,有可能达到汇点的所有流均到达汇点。因为管道服从容量限制,',
            '并且通过任何割的流量依然受到割的容量限制,这时再没有流能到达汇点了')
        print('基本操作')
        print('  压入与重标记算法中要执行两种基本操作:把流的余量从一顶点压入到它的一个相邻顶点,以及重标记一个顶点',
            '采用这两种操作中的哪一种取决于顶点的高度.顶点的高度的准确定义：')
        print('设G=(V,E)是一个流网络,其源点为s,汇点为t.设f是G的一个前置流.如果函数h:V->N满足h(s)=|V|,h(t)=0',
            '且对每条残留边(u,v)∈Ef,有h(u)<=h(v)+1,则该函数为高度函数')
        print('引理26.13 设G=(V,E)是一个网络流,其源点为s,汇点为t.设f是G的一个前置流.h是定义在V上的高度函数',
            '对任意两顶点u`,v∈V,如果h(u)>h(v)+1,则(u,v)不是残留图中的边')
        print('压入操作')
        print('  如果u是某溢出顶点,cf(u,v)>0且h(u)=h(v)+1,则可以应用基本操作PUSH(u,v)',
            '对隐式给出的网络G=(V,E)中的前置流f进行更新,它假定对给定的c和f可以在常数时间内计算出残留容量',
            '存储于顶点u的余流用e[u]表示,u的高度用h[u]表示.符号df(u,v)是存储能够从u压入到v的流量的一个临时变量')
        print('  称PUSH(u,v)是一个从u到v的压入.如果压入操作适用于离开顶点u的某边(u,v),则也可以说压入操作适用于u',
            '如果边(u,v)变为饱和(压入后cf(u,v)=0),则该压入是饱和压入,否则就是一个不饱和压入.如果一条边是饱和的,',
            '则它不出现在残留网络中.一个简单的引理说明了不饱和压入的结果')
        print('引理26.14 在一次从u到v的不饱和压入操作后,顶点u不再溢出')
        print('重标记操作')
        print('  如果u是溢出顶点，且对所有边(u,v)∈Ef有h[u]<=h[v],则可以应用基本操作RELABEL(u).',
            '已知溢出顶点u,如果对从u到v还存在残留容量的每一个顶点v,由于v的高度不在u之下而使我们',
            '不能把流从u压入到v,则此时可以重标记溢出顶点u','源点s和汇点t都不可能是溢出顶点,因此s和t都不能被重标记')
        print('  调用操作RELABEL(u)时,说顶点u被重标记了.当u被重标记时,Ef必须至少包含一条离开u的边')
        print('  操作RELABEL(u)使u在高度函数约束下,具有所允许的最大高度')
        print('一般性算法')
        print('  在流网络中建立一个初始前置流')
        print('  INITIALIZE-FREFLOW建立的初始前置流f定义为')
        print('    f[u,v]=c(u,v); if u == s')
        print('    f[u,v]=-c(v,u); if v == s')
        print('    f[u,v]=0 else')
        print('  即每条边离开源点s的边被充满,而其他所有边不运载任何流.对每个与源点邻接的顶点v',
            '开始时有e[v]=c(s,v),e[s]被初始化为这些容量的和的负值')
        print('  一般性算法中也从高度函数h开始.h由下式给出')
        print('     h[u]=|V|; 如果u=s')
        print('     h[u]=0  else')
        print('  这是一个高度函数,因为满足h[u]>h[v]+1的边(u,v)仅是那些满足u==s的边,',
            '并且那些边是饱和的,这意味着它们不在残留网络中')
        print('引理26.15 (溢出的顶点可以被压入或重标记) 设G=(V,E)是一个流网络,源点为s',
            '汇点为t,f为一前置流。设h是f的任意高度函数.如果u是任意溢出顶点,则压入操作或重标记操作适用于该顶点')
        print('压入与重标记方法的正确性')
        print('  一般性算法压入与重标记算法解决了最大流问题,如果算法终止,则前置流f为一个最大流')
        print('引理26.16 (顶点高度不会减小) GENERIC-PUSH-RELABEL在流网路G=(V,E)上执行过程中,对每个顶点u∈V',
            '其高度h[u]至少增加1')
        print('引理26.17 设G=(V,E)是一个流网络,其源点为s,汇点为t.在GENERIC-PUSH-RELABEL对G的执行过程中,属性h始终为高度函数')
        print('引理26.18 设G=(V,E)是一个流网络,其源点为s,汇点为t.设f是G的一前置流,h是定义在V上的高度函数',
            '则在残留网络Gf中不存在从源点s到汇点t的路径')
        print('定理26.19(一般性压入与重标记算法的正确性) 当算法GENERIC-PUSH-RELABEL在具有源点s和汇点t的流网络G=(V,E)上运行时',
            '若算法终止,则它计算出的前置流f为G的最大流')
        print('对压入与重标记方法的分析')
        print('  对于三种类型的操作(重标记,饱和压入和不饱和压入)中的每一种,分别给出其界',
            '有了这些界后,构造一个运行时间为O(V^2E)的算法就成为一个简单的问题了')
        print('引理26.20 设G=(V,E)是源点为s,汇点为t的一个流网络,且f是G的前置流.',
            '则对任意溢出顶点u,在残留网络Gf中存在着一条从u到s的简单路径')
        print('引理26.21 设G=(V,E)是一个网络流,其源点为s,汇点为t.GENERIC-PUSH-RELABEL在G上执行过程中的任何时刻',
            '对所有的顶点u∈V,都有h[u]<=2|V|-1')
        print('  证明:因为根据定义,源点s和汇点t均不是溢出顶点,所以它们的高度不会改变.',
            '因此总是有h[s]=|V|和h[t]=0,都不会大于2|V|-1')
        print('推论26.22 (关于重标记操作的界) 设G=(V,E)是一个流网络,其源点为s,汇点为t.',
            '在GENERIC-PUSH-RELABEL对G的执行过程中,对每个顶点执行重标记操作的次数之多为2|V|-1',
            '全部重标记操作的执行次数至多为(2|V|-1)(|V|-2)<2|V|^2')
        print('引理26.23 (关于饱和压入的界) 在GENERIC-PUSH-RELABEL对任意流网络G=(V,E)的执行过程中,',
            '饱和压入的次数至多为2|V||E|')
        print('引理26.24 (关于不饱和压入的界) 在GENERIC-PUSH-RELABEL对任意流网络G=(V,E)的执行过程中',
            '不饱和压入的次数至多为:4|V|^2(|V|+|E|)')
        print('定理26.25 在GENERIC-PUSH-RELABEL对任意流网络G=(V,E)的执行过程中,基本操作的执行次数为O(V^2E)')
        print('推论26.26 对任意流网络G=(V,E),存在一种压入与重标记算法的实现,其运行时间为O(V^2E)')
        print('练习26.4-1 说明如何实现一般性压入与重标记算法,使得每次重标记操作需要O(V)时间,每次压入操作需要O(1)时间',
            '选择可应用的操作需要O(1)时间,而整个算法的时间为O(V^2E)')
        print('练习26.4-2 证明：在执行全部的O(V^2)次重标记操作,一般性压入与重标记算法所需的全部运行时间仅为O(VE)')
        print('练习26.4-3 假定运用压入与重标记算法找出了流网络G=(V,E)中的最大流.',
            '试给出一种快速算法来找出G的最小割')
        print('练习26.4-4 写出一个有效的压入与重标记算法,以找出一个二分图的最大匹配')
        print('练习26.4-5 假定在流网络G=(V,E)中,所有边的容量都属于集合{1,2,...,k}.',
            '试用|V|,|E|和k来分析一般性压入与重标记算法的时间(一条边在成为饱和边前能承受多少次不饱和压入)')
        print('练习26.4-6 证明INITIALIZE-PREFLOW的第7行可以改为h[s]<-|V[G]|-2,',
            '这并不影响一般性压入与重标记算法的正确性或其渐进意义上的性能')
        print('练习26.4-7 设df(u,v)为残留网络Gf中从u到v的距离(边数).证明GENERIC-PUSH-RELABEL保持下列性质:',
            '若h[u]<|V|,则h[u]<=df(u,t);并且h[u]>=|V|,则h[u]-|V|<=df(u,s)')
        print('练习26.4-8 如上一个练习题中一样,设df(u,v)为残留网络Gf中从u到v的距离.',
            '说明如何修改一般性压入与重标记算法以保持下列性质:')
        print('  若h[u]<|V|,则h[u]=df(u,t);并且若h[u]>=|V|,则h[u]-|V|=df(u,s)',
            '为保持这一性质,算法的全部运行时间为O(VE)')
        print('练习26.4-9 证明对于|V|>=4,在流网络G=(V,E)上运行GENERIC-PUSH-RELABEL',
            '所执行的非饱和压入操作的次数至多为4|V|^2|E|')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_5:
    '''
    chpater26.5 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.5 note

        Example
        ====
        ```python
        Chapter26_5().note()
        ```
        '''
        print('chapter26.5 note as follow')  
        print('26.5 重标记与前移算法')
        print('压入与重标记方法允许以任意次序执行基本操作.但是,通过仔细选择执行次序和有效安排网络的数据结构',
            '可以用比推论26.26给出的O(V^2E)更少的运行时间来解决最大流问题.')
        print('重标记与前移算法,这是一种运行时间为O(V^3)的压入与重标记算法,',
            '从渐进意义上来看,对于稠密网络它至少不弱于O(V^2E)')
        print('重标记与前移算法设置了一张网络中顶点表,算法从表的前端开始扫描表,反复选出溢出顶点u,然后\"排除\"它,',
            '即反复执行压入和重标记操作,直至顶点u不再存在正的余流,当某个顶点被重标记时,就被移动到表的前端(所以算法名为\"重标记与前移\")',
            '算法又重新开始扫描')
        print('重标记算法与前移算法的正确性及其性能分析与概念\"容许\"边(admissible edge)有关',
            '即残留网络中压入的流经过的那些边.在证明关于容许网络的几条性质后,将讨论排出操作,最后给出并分析重标记与前移算法')
        print('容许边和容许网络')
        print('  设G=(V,E)是一个流网络,其源点为s,汇点为t.f是G的前置流,h是高度函数,则如果cf(u,v)>0',
            '且h(u)=h(v)+1,就说(u,v)是容许边.否则，(u,v)是非容许边.容许网络为Gf,h=(V,Ef,h),其中Ef,h为容许边的集合')
        print('引理26.27 (容许网络中不包含回路) 如果G=(V,E)是一个流网络,f是G的一个前置流,且h是G上的高度函数,',
            '则容许网络Gf,h=(V,Ef,h)中不包含回路')
        print('引理26.28 设G=(V,E)是一个流网络,f是G的一个前置流,且h是G上的高度函数.',
            '如果顶点u是溢出顶点且(u,v)是容许边,则采用PUSH(u,v).该操作不会建立任何新的容许边,但它可能使(u,v)变为非容许边')
        print('引理26.29 设G=(V,E)是一个流网络,f是G的一个前置流,且h是G上的高度函数.如果顶点u是溢出顶点,并且不存在在离开u的容许边',
            '则此时RELABEL(u)适用.在执行重标记操作后,至少存在一条离开u的容许边,但不会进入u的容许边')
        print('相邻表')
        print('  重标记与前移算法中的边都被放入\"相邻表\"中.如果给定流网络G=(V,E),',
            '对顶点u∈V,其相邻表N[u]是一个关于G中u的相邻顶点的单链表')
        print('  因此,如果(u,v)∈E或(v,u)∈E,则顶点v出现在表N[u]中.相邻表N[u]仅仅包含哪些可能存在残留边(u,v)的顶点v',
            'N[u]中的第一个顶点由head[N[u]]指出。相邻表中v的下一个顶点由指针next-neighbor[v]指出；',
            '如果v是相邻表中的最后一个顶点,则该指针为None')
        print('  重标记与前移算法在执行过程中,按某确定的顺序循环访问每个相邻表.对每个顶点u,',
            '域current[u]指向N[u]中当前被考察的顶点.current[u]开始时被置为head[N[u]]')
        print('溢出顶点的排除')
        print('  一个溢出顶点u通过下列方式排除：把该顶点的所有余流通过容许边压入到相邻顶点',
            '必要时重标记顶点u,使离开u的边变成容许边')
        print('重标记与前移算法')
        print('  设置包含V-{s,t}中所有顶点的链表L.',
            '该链表的一个重要性质是根据容许网络对表中的所有顶点进行拓扑排序')
        print('  容许网络是一个有向无回路图')
        print('在重标记与前移算法伪代码中,假设对每个顶点u已经建立了相邻表N[u]',
            '并假定next[u]指向L中u的后继顶点.若是表中的最后一个顶点,则next[u]=None')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

chapter26_1 = Chapter26_1()
chapter26_2 = Chapter26_2()
chapter26_3 = Chapter26_3()
chapter26_4 = Chapter26_4()
chapter26_5 = Chapter26_5()

def printchapter26note():
    '''
    print chapter26 note.
    '''
    print('Run main : single chapter twenty-six!')  
    chapter26_1.note()
    chapter26_2.note()
    chapter26_3.note()
    chapter26_4.note()
    chapter26_5.note()

# python src/chapter26/chapter26note.py
# python3 src/chapter26/chapter26note.py
if __name__ == '__main__':  
    printchapter26note()
else:
    pass
