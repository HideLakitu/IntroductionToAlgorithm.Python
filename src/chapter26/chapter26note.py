# coding:utf-8
# usr/bin/python3
# python src/chapter26/chapter26note.py
# python3 src/chapter26/chapter26note.py
'''

Class Chapter26_1

Class Chapter26_2

Class Chapter26_3

Class Chapter26_4

Class Chapter26_5

'''
from __future__ import absolute_import, division, print_function

import math as _math
import random as _random
import time as _time
from copy import copy as _copy
from copy import deepcopy as _deepcopy
from random import randint as _randint

import numpy as np
from numpy import arange as _arange
from numpy import array as _array

if __name__ == '__main__':
    import flownetwork as _fn
else:
    from . import flownetwork as _fn

class Chapter26_1:
    '''
    chpater26.1 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.1 note

        Example
        ====
        ```python
        Chapter26_1().note()
        ```
        '''
        print('chapter26.1 note as follow')  
        print('第26章 最大流')
        print('为了求从一点到另一点的最短路径，可以把公路地图模型化为有向图')
        print('可以把一个有向图理解为一个流网络,并运用它来回答有关物流方面的问题')
        print('设想某物质从产生它的源点经过一个系统,流向消耗该物质的汇点(sink)这样一种过程')
        print('源点以固定速度产生该物质,而汇点则用同样的速度消耗该物质.',
            '从直观上看,系统中任何一点的物质的流为该物质在系统中运行的速度')
        print('物质进入某顶点的速度必须等于离开该顶点的速度,流守恒性质,',
            '当物质是电流时,流守恒与基尔霍夫电流定律等价')
        print('最大流问题是关于流网络的最简单的问题')
        print('26.1 流网络')
        print('流网络的流')
        print('  流网络G=(V,E)是一个有向图,其中每条边(u,v)∈E均有一非负容量c(u,v)>=0',
            '如果(u,v)∉E,则假定c(u,v)=0。流网络中有两个特别的顶点：源点s和汇点t',
            '为了方便起见，假定每个顶点均处于从源点到汇点的某条路径上，就是说,每个顶点v∈V,存在一条路径s->v->t',
            '因此,图G为连通图,且|E|>=|V|-1')
        print('流的定义')
        print('  设G=(V,E)是一个流网络,其容量函数为c。设s为网络的源点，t为汇点。',
            'G的流是一个实值函数f:V*V->R,且满足下列三个性质：')
        print('  (1) 容量限制：对所有u,v∈V,要求f(u,v)<=c(u,v)')
        print('  (2) 反对称性：对所有u,v∈V,要求f(u,v)=-f(v,u)')
        print('  (3) 流守恒性：对所有u∈V-{s,t},要求∑f(u,v)=0')
        print('  f(u,v)称为从顶点u到顶点v的流，可以为正，为零，也可以为负。流f的值定义为|f|=∑f(s,v)',
            '即从源点出发的总流.在最大流问题中,给出一个具有源点s和汇点t的流网络G,希望找出从s到t的最大值流')
        print('容量限制只说明从一个顶点到另一个顶点的网络流不能超过设定的容量',
            '反对称性说明从顶点u到顶点v的流是其反向流求负所得.',
            '流守恒性说明从非源点或非汇点的顶点出发的总网络流为0')
        print('定义某个顶点处的总的净流量(total net flow)为离开该顶点的总的正能量,减去进入该顶点的总的正能量')
        print('流守恒性的一种解释是这样的,即进入某个非源点非汇点顶点的正网络流，必须等于离开该顶点的正网络流',
            '这个性质(即一个顶点处的总的净流量必定为0)常常被形式化地称为\"流进等于流出\"')
        print('通常，利用抵消处理，可以将两城市间的运输用一个流来表示,该流在两个顶点之间的至多一条边上是正的')
        print('给定一个实际运输的网络流f,不能重构其准确的运输路线,如果知道f(u,v)=5,',
            '如果知道f(u,v)=5,表示有5个单位从u运输到了v,或者表示从u到v运输了8个单位,v到u运输了3个单位')
        print('本章的算法将隐式地利用抵消,假设边(u,v)有流量f(u,v).在一个算法的过程中,可能对边(u,v)上的流量增加d',
            '在数学上,这一操作为f(u,v)减d；从概念上看,可以认为这d个单位是对边(u,v)上d个单位流量的抵消')
        print('具有多个源点和多个汇点的网络')
        print('  在一个最大流问题中,可以有几个源点和几个汇点,而非仅有一个源点和一个汇点',
            '比如物流公司实际可能拥有m个工厂{s1,s2,...,sm}和n个仓库{t1,t2,...,tn}',
            '这个问题不比普通的最大流问题更难')
        print('  在具有多个源点和多个汇点的网络中,确定最大流的问题可以归约为一个普通的最大流问题',
            '通过增加一个超级源点s,并且对每个i=1,2,...,m加入有向边(s,si),其容量c(s,si)=∞',
            '同时创建一个超级汇点t,并且对每个j=1,2,...,n加入有向边(tj,t),其容量c(tj,t)=∞')
        print('  单源点s对多个源点si提供了其所需要的任意大的流.同样,单汇点t对多个汇点tj消耗其所需要的任意大的流')
        print('对流的处理')
        print('  下面来看一些函数(如f),它们以流网络中的两个顶点作为自变量',
            '在本章,将使用一种隐含求和记号,其中任何一个自变量或两个自变量可以是顶点的集合',
            '它们所表示的值是对自变量所代表元素的所有可能的情形求和')
        print('  流守恒限制可以表述为对所有u∈V-{s,t},有f(u,V)=0,',
            '同时,为方便起见,在运用隐含求和记法时,省略集合的大括号.例如,在等式f(s,V-s)=f(s,V)中',
            '项V-s是指集合V-{s}')
        print('隐含集合记号常可以简化有关流的等式.下列引理给出了有关流和隐含记号的几个恒等式')
        print('引理26.1 设G=(V,E)是一个流网络,f是G中的一个流.那么下列等式成立')
        print(' 1) 对所有X∈V,f(X,X)=0')
        print(' 2) 对所有X,Y∈V,f(X,Y)=-f(Y,X)')
        print(' 3) 对所有X,Y,Z∈V,其中X∧Y!=None,有f(X∨Y,Z)=f(X,Y)+f(Y,Z)且f(Z,X∨Y)=f(Z,X)+f(Z,Y)')
        print('作为应用隐含求和记法的一个例子,可以证明一个流的值为进入汇点的全部网络流,即|f|=f(V,t)')
        print('根据流守恒特性,除了源点和汇点以外,对所有顶点来说,进入顶点的总的正流量等于离开该顶点的总的正能量',
            '根据定义,源点顶点总的净流量大于0；亦即，对源点顶点来说，离开它的正流要比进入它的正流更多',
            '对称地，汇点顶点是唯一一个其总的净流量小于0的顶点;亦即,进入它的正流要比离开它的正流更多')
        print('练习26.1-1 利用流的定义，证明如果(u,v)∉E,且(v,u)∉E,有f(u,v)=f(v,u)=0')
        print('练习26.1-2 证明：对于任意非源点非汇点的顶点v,进入v的总正向流必定等于离开v的总正向流')
        print('练习26.1-3 证明在具有多个源点和多个汇点的流网络中,任意流均对应于通过增加一个超级源点',
            '和超级汇点所得到的具有相同值的一个单源点单汇点流')
        print('练习26.1-4 证明引理26.1')
        print('练习26.1-5 在所示的流网络G=(V,E)和流f,找出两个子集合X,Y∈V,且满足f(X,Y)=-f(V-X,Y)',
            '再找出两个子集合X,Y∈V,且满足f(X,Y)!=-f(V-X,Y)')
        print('练习26.1-6 给定流网络G=(V,E),设f1和f2为V*V到R上的函数.流的和f1+f2是从V*V到R上的函数',
            '定义如下：对所有u,v∈V (f1+f2)(u,v)=f1(u,v)+f2(u,v)',
            '如果f1和f2为G的流,则f1+f2必满足流的三条性质中的哪一条')
        print('练习26.1-7 设f为网络中的一个流,a为实数。标量流之积是一个从V*V到R上的函数,定义为(af)(u,v)=a*f(u,v)',
            '证明网络中的流形成一个凸集','即证明如果f1和f2是流,则对所有0<=a<=1,af1+(1-a)f2也是流')
        print('练习26.1-8 将最大流问题表述为一个线性规划问题')
        print('练习26.1-9 略')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_2:
    '''
    chpater26.2 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.2 note

        Example
        ====
        ```python
        Chapter26_2().note()
        ```
        '''
        print('chapter26.2 note as follow')  
        print('Ford-Fulkerson方法')
        print('解决最大流问题的Ford-Fulkerson方法,包含具有不同运行时间的几种实现')
        print('Ford-Fulkerson方法依赖于三种重要思想')
        print(' 残留网络,增广路径,割')
        print('这些思想是最大流最小割定理的精髓,该定理用流网络的割来描述最大流的值')
        print('Ford-Fulkerson方法是一种迭代方法.开始时,对所有u,v∈V,有f(u,v)=0,即初始状态时流的值为0',
            '在每次迭代中,可通过寻找一条\"增广路径\来增加流的值"。增广路径可以看作是从源点s到汇点t之间的一条路径',
            '沿该路径可以压入更多的流,从而增加流的值.反复进行这一过程,直至增广路径都被找出为止',
            '最大流最小割定理将说明在算法终止时,这一过程可产生出最大流')
        print('残留网络')
        print('  直观上,给定流网络和一个流,其残留网络由可以容纳更多网络流的边所组成',
            '更形式地,假定有一个网络G=(V,E),其源点为s,汇点到t.设f为G中的一个流,并考察一对顶点u,v∈V',
            '在不超过容量c(u,v)的条件下,从u到v之间可以压入的额外网络流量,就是(u,v)的残留容量(residual capacity),由下式定义:',
            'cf(u,v)=c(u,v)-f(u,v)')
        print('  例如,如果c(u,v)=16且f(u,v)=11,则在不超过边(u,v)的容量限制的条件下,可以再传输cf(u,v)=5个单位的流来增加f(u,v)',
            '当网络流f(u,v)为负值时,残留容量cf(u,v)大于容量c(u,v)')
        print('  例如,如果c(u,v)=16且f(u,v)-4,残留容量cf(u,v)为20')
        print('  解释：从v到u存在着4个单位的网络流,可以通过从u到v压入4个单位的网络来抵消它',
            '然后,在不超过边(u,v)的容量限制的条件下,还可以从u到v压入另外16个单位的网络流',
            '因此,从开始的网络流f(u,v)-4,共压入了额外的20个单位的网络流,并不会超过容量限制')
        print('  在残留网络中,每条边(或称为残留边)能够容纳一个严格为正的网络流')
        print('Ef中的边既可以是E中的边,也可以是它们的反向边',
            '如果边(u,v)∈E有f(u,v)<c(u,v),那么cf(u,v)=c(u,v)-f(u,v)>0且(u,v)属于Ef')
        print('只有当两条边(u,v)和(v,u)中,至少有一条边出现于初始网络中时,边(u,v)才能够出现在残留网络中,所以有如下限制条件:',
            '|Ef|<=2|E|.残留网络Gf本身也是一个流网络,其容量由cf给出.下列引理说明残留网络中的流与初始网络中的流有何关系')
        print('引理26.2 设G=(V,E)是源点为s,汇点为t的一个流网络,且f为G中的一个流',
            '设Gf是由f导出的G的残留网络,且f’为Gf中的一个流,其值|f+f`|=|f|+|f`|')
        print('增广路径')
        print('  已知一个流网络G=(V+E)和流f,增广路径p为残留网络Gf中从s到t的一条简单路径',
            '根据残留网络的定义,在不违反边的容量限制条件下,增广路径上的每条边(u,v)可以容纳从u到v的某额外正网络流')
        print('引理26.3 设G=(V,E)是一个网络流,f是G的一个流,并设p是Gf中的一条增广路径.',
            '用下式定义一个函数：fp：V*V->R')
        print('fp(u,v)=cf(p);fp(u,v)=-cf(p);fp(u,v)=0')
        print('则fp是Gf上的一个流,其值为|fp|=cf(p)>0')
        print('推论26.4 设G=(V,E)是一个流网络,f是G的一个流,p是Gf中的一条增广路径')
        print('流网络的割')
        print('  Ford-Fulkerson方法沿增广路径反复增加流,直至找出最大流为止.',
            '要证明的最大流最小割定理：一个流是最大流,当且仅当它的残留网络不包含增广路径')
        print('流网络G=(V,E)的割(S,T)将V划分成S和T=V-S两部分,使得s∈S,t∈T')
        print('一个网络的最小割也就是网络中所有割中具有最小容量的割')
        print('引理26.5 设f是源点s,汇点为t的流网络G中的一个流.并且(S,T)是G的一个割',
            '则通过割(S,T)的净流f(S,T)=|f|')
        print('推论26.6 对一个流网络G中任意流f来说,其值的上界为G的任意割的容量')
        print('定理26.7(最大流最小割定理) 如果f是具有源点s和汇点t的流网络G=(V,E)中的一个流,则下列条件是等价的:',
            '1) f是G的一个最大流')
        print('2) 残留网络Gf不包含增广路径')
        print('3) 对G的某个割(S,T),有|f|=c(S,T)')
        print('基本的Ford-Fulkerson算法')
        print('  在Ford-Fulkerson方法的每次迭代中,找出任意增广路径p,并把沿p每条边的流f加上其残留容量cf(p)',
            '在Ford-Fulkerson方法的以下实现中,',
            '通过更新有边相连的每对顶点u,v之间网络流f[u,v],来计算出图G=(V,E)中的最大流')
        print('如果u和v之间在任意方向没有边相连,则隐含地假设f[u,v]=0',
            '假定已经在图中给出,且如果(u,v)∉E,有c(u,v)=0.残留容量cf(u,v)',
            '代码中的符号cf(p)实际上只是存储路径p的残留容量的一个临时变量')
        print('Ford-Fulkerson算法的分析')
        print('  Ford-Fulkerson算法过程的运行时间取决于如何确定第4行中的增广路径,',
            '如果选择不好,算法甚至可能不会终止;流的值随着求和运算将不断增加,但它甚至不会收敛到流的最大值')
        print('  如果采用广度优先搜索来选择增广路径,算法的运行时间为多项式时间复杂度')
        print('  但是,在证明这一点之前,先任意选择增广路径、且所有容量均为整数,取得一个简单的界')
        print('在实际中碰到的大多数最大流的问题中其容量经常为整数,如果容量为有理数,则经过适当的比例转换,都可以使它们变为整数')
        print('在这一假设下,Ford-Fulkerson的一种简易实现的运行时间为O(E|f*|)')
        print('Edmonds-Karp算法')
        print('  如果在Ford-Fulkerson算法使用广度优先搜索来实现对增广路径p的计算',
            '即如果增广路径是残留网格中从s到t的最短路径(其中每条边为单位距离或权)',
            '则能够改进FORD-FULKERSON的界,这种方法称为Edmonds-Karp算法,运行时间为O(VE^2)')
        print('引理26.8 如果对具有源点s和汇点t的流网络G=(V,E)运行Edmonds-Karp算法,则对所有顶点v∈V-{s,t}',
            '残留网络Gf中的最短路径长度df(u,v)随着每个流的增加而单调递增')
        print('定理26.9 如果对具有源点s和汇点t的一个流网络G=(V,E)运行Edmonds-Karp算法,对流进行增加的全部次数为O(VE)')
        print('  在一个残留网络Gf中,如果对其增广路径p的残留容量是边(u,v)的残留容量,即,如果cf(p)=cf(u,v),则说边(u,v)对增广路径p是关键的',
            '在沿增广路径对流进行增加后,该路径上的任何关键边便从残留网络中消失')
        print('  在增广路径上至少有一条边必为关键边.|E|条边中的每一条都可能至多|V|/2-1次地成为关键边')
        print('用于在用广度优先搜索寻找增广路径时,FORD-FULKERSON中的每次迭代都可以在O(E)的运行时间内完成',
            '所以Edmonds-Karp算法的全部运行时间为O(V^2E).压入与重标记算法能够达到更好的界')
        print('练习26.2-1 斜杠左边表示流,右边表示容量;流是19,容量是')
        print('练习26.2-2 Edmonds-Karp算法的执行过程')
        _fn.test_edmonds_karp()
        print('练习26.2-3 在图26-5中,对应于图中最大流的最小割是多少',
            '在例中出现的增广路径中,哪两条路径抵消了先前被传输的流')
        print('练习26.2-4 证明对任意一对顶点u和v、任意的容量和流函数c和f,有:',
            'cf(u, v)+cf(v, u)=c(u,v)+c(v,u)')
        print('练习26.2-5 通过增加具有无限容量的边,把一个多源点多汇点的流网络转换为单源点单汇点的流网络',
            '证明:如果初始的多源点多汇点网络中的边具有有限的容量,则转换后所得的网络中的任意流均为有限值')
        print('练习26.2-6 假定在多源点多汇点问题中,每个源点si产生pi单位的流,即f(si,V)=pi.同时假定每个汇点tj消耗qj单位的流',
            '即f(V,ti)=qj,其中∑pi=∑pj,说明如何把寻找一个流f以满足这些附加限制的问题,转化为在一个单源点单汇点流网络中寻找最大流的问题')
        print('练习26.2-7 证明引理26.3')
        print('练习26.2-8 证明：一个网络G=(V,E)的最大流总可以被至多由|E|条增广路径所组成的序列发现(找出最大流后再确定路径)')
        print('练习26.2-9 无向图边连通度(edge connectivity)是指为了使图不连通而必须去掉的最少边数k',
            '例如,数的边连通度为1,顶点的循环链的边连通度是2,说明如何对至多|V|个流网络',
            '(每个流网络有O(V)个顶点和O(E)条边运行最大流算法),就可以确定无向图G=(V,E)的边连通度')
        print('练习26.2-10 假定一个流网络G=(V,E)中有对称边,也就是(u,v)∈E当且仅当(v,u)∈E',
            '试证明Edmonds-Karp算法在至多进行|V||E|/4次迭代后将终止执行',
            '(对任意边(u,v),考虑(u,v)为关键边的时刻之间,d(s,u)和d(v,t)是如何变化的)')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_3:
    '''
    chpater26.3 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.3 note

        Example
        ====
        ```python
        Chapter26_3().note()
        ```
        '''
        print('chapter26.3 note as follow')  
        print('26.3 最大二分匹配')
        print('一些组合问题可以很容易地转换为最大流问题.26.1节中的多源点,多汇点最大流问题就是一个例子')
        print('如在一个二分图中寻找最大匹配.为了解决这一问题,将利用Ford-Fulkerson方法提供的完整性性质')
        print('可以应用Ford-Fulkerson方法在O(VE)时间内解决图G=(V,E)的最大二分匹配问题')
        print('最大二分匹配问题')
        print('  给定一个无向图G=(V,E),一个匹配(matching)是一个边的子集合,且满足对所有的顶点v∈V,M中至多一条边与v关联',
            '如果M中某条边与v关联,则说顶点v∈V被匹配,否则说v是无匹配的.最大匹配是最大势的匹配,也就是说,是满足对任意匹配M`',
            '有|M|>=|M`|的匹配M')
        print('  假定顶点集合可被划分为V=L∨R,其中L和R是不相交的,且E中的所有边的一个端点在R中,另一端点在L中',
            '进一步假设V中的每个顶点至少有一条关联的边')
        print('  二分图的最大匹配问题有着许多世纪的应用.例如,把一个机器集合L和要同时执行的任务集合R相匹配。',
            'E中有边(u,v),就说明一台特定机器u∈L能够完成一项特定任务v∈R,最大匹配可以为尽可能多的机器提供任务')
        print('寻找最大二分匹配')
        print('  利用Ford-Fulkerson方法可以在关于|V|和|E|的多项式时间内,找出无向二分图G=(V,E)的最大匹配',
            '解决这一问题的关键技巧在于建立一个流网络,其中流对应于匹配')
        print('  对二分图G的相应流网络G`=(V`,E`)定义如下,设源点s和汇点t是不属于V的新顶点')
        print('V`=V∪{s,t}.如果G的顶点划分为V=L∪R,G`的有向边为E的边,从L指向R,再加上V条新边:')
        print('E`={(s,u):u∈L}∪{(u,v):u∈L,v∈R,(u,v)∈E}∪{(v,t):v∈R}')
        print('在结束构造工作之前,在E`中的每条边赋予单位容量.因为V中的每个顶点至少有一条关联边',
            '|E|>=|V|/2.因此|E|<=|E`|=|E|+|V|<=3|E|,则|E`|=Θ(E)')
        print('引理26.10 设G=(V,E)是一个二分图,其定点划分为V=L∪R,设G`=(V`,E`)是它相应的流网络',
            '如果M是G的匹配,则G`中存在一个整数值的流f,且|f|=|M|.',
            '相反地,如果f是G`的整数值流,则G中存在一匹配M满足|M|=|f|')
        print('在一个二分图G中,一个最大匹配对应于流网络G`中的一个最大流.因此,可以通过对G`运行最大流算法来计算出G的最大匹配',
            '这一推理过程中存在的唯一故障就是最大流算法可能返回一个G`的非整数量的流f(u,v),即使流的值|f|应该为一个整数')
        print('定理26.11(完整性定理)如果容量函数c只取整数值,则由Ford-Fulkerson方法得出的最大流f满足|f|为整数的性质',
            '此外,对所有顶点u和v,f(u,v)的值为整数')
        print('推论26.12 二分图G的一个最大匹配M的势是其相应的流网络G`中的某一最大流f的值')
        print('对于一个无向二分图G,可以利用下列方法找出其最大匹配:先建立流网络G`,对它进行Ford-Fulferson方法',
            '根据求得的具有整数值的最大流f,就可直接获得最大匹配M,因为二分图上的任何匹配的势至多为min(L,R)=O(V)',
            '所以G`中最大流的值为O(V),因此,可以在O(VE`)=O(VE)的时间内,找出一个二分图的最大匹配,因为|E`|=Θ(E)')
        print('练习26.3-1 对图26-8b中所示的流网络运行Ford-Fulkerson算法.并指出每次对流增加以后所得的残留网络,对L中的顶点从上到下编为1-5号,对R中的顶点从上到下编号为6-9号',
            '在每次迭代中,找出按辞典顺序排列时,最小的一条增广路径')
        print('练习26.3-2 证明定理26.11')
        print('练习26.3-3 设G=(V,E)为二分图,其定点划分为V=L∨R,且G`是其相应的流网络',
            '在Ford-Fulkerson执行过程中,对在G`中找出的任意增广路径的长度给出一个适当的上界')
        print('练习26.3-4 完全匹配(perfect matching)是指图中每个顶点均被匹配,设G=(V,E)是其定点分划为V=L∪R的一个无向二分图',
            '其中|L|=|R|.对任意X∈V,定义X的邻居为N(X)={y∈V,(x,y)∈E,对某个x∈X}',
            '即,由与X的某元素相邻的顶点所构成的集合.证明Hall定理：G中存在一个完全匹配,当且仅当对每个子集A∈L,有|A|<=|N(A)|')
        print('练习26.3-5 在二分图G=(V,E)中,V=L∪R,如果每个顶点v∈V的度均为d,则说该图是d正则的.每个d正则二分图有|L|=|R|',
            '证明:对每个d正则二分图,其相应流网络的最小割的容量为|L|.',
            '运用该结论证明:每个d正则二分图均有一个势为|L|的匹配')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_4:
    '''
    chpater26.4 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.4 note

        Example
        ====
        ```python
        Chapter26_4().note()
        ```
        '''
        print('chapter26.4 note as follow')  
        print('26.4 压入与重标记算法')
        print('目前许多关旭最大流问题的渐进最快速算法就是压入与重标记算法,',
            '最大流算法最快速的实际实现都是基于压入与重标记方法的')
        print('其他有关流的问题,如最小代价流问题,也可以有效地利用压入与重标记方法来解决')
        print('Goldberg的一般性最大流算法,该算法有一种简单的实现,其运行时间为O(V^2E),',
            '这是对Edmonds-Karp算法的O(VE^2)时间的一种改进,26.5节中对一般性算法进行进一步的精化',
            '得到另外一种运行时间为O(V^3)的压入与重标记算法')
        print('相对于Ford-Fulkerson方法来说,压入与重标记采用的是一种更局部化的方法',
            '它不是检查整个残留网络G=(V,E)来找出增广路径','而是每次仅对一个顶点进行操作',
            '并且仅检查残留网络中该顶点的相邻顶点')
        print('此外,与Ford-Fulkerson方法不同,压入与重标记算法在执行过程中,并不能保持流守恒特性')
        print('但是,该算法保持了一个前置流,它是一个函数f:V*V->R,他满足反对称性、容量限制和下列放宽条件的流守恒性特性',
            '对所有顶点u∈V-{s},有f(V,u)>=0.亦即,进入除源顶点以外的顶点的总净流为非负值.进入顶点u的总净流称为进入u的余流',
            '由下式给出e(u)=f(V,u),对一个顶点u∈V-{s,t},如果e(u)>0,则称顶点u溢出')
        print('压入与重标记方法所包含的直观思想')
        print('  把一个流网络G=(V,E)看成是具有给定容量、且互相连接的管道所组成的系统',
            '把这个比方应用到Ford-Fulkerson方法中,可以说网络中的每一条增广路径均引发一条无分支点',
            '从源点到汇点的额外液体流,Ford-Fulkerson方法以迭代的方式加入更多的流,直至不能加入时为止')
        print('  从直观上看,一般性压入与重标记算法的思想在某种程度上来说有所不同.和先前一样,图的有向边对应于管道',
            '而作为管道结合点的顶点却有着两个有趣的特性.第一，为了容纳余流,每个顶点均有一个排出管道',
            '它导向能积聚液体的任意大容量水库','每个顶点和它的水库以及所有的管道连接点都处于一个平台上,当算法向前压入时,平台随之逐渐升高')
        print('  顶点的高度决定了如何压入流:仅仅把流向下压,即从较高顶点向较低顶点压',
            '从较低顶点到较高顶点可能存在一正向网络流,但是对流的压入总是向下压',
            '源点的高度固定为|V|,汇点的高度固定为0.所有其他顶点的高度开始时都是零,并逐步增加')
        print('  最终,有可能达到汇点的所有流均到达汇点。因为管道服从容量限制,',
            '并且通过任何割的流量依然受到割的容量限制,这时再没有流能到达汇点了')
        print('基本操作')
        print('  压入与重标记算法中要执行两种基本操作:把流的余量从一顶点压入到它的一个相邻顶点,以及重标记一个顶点',
            '采用这两种操作中的哪一种取决于顶点的高度.顶点的高度的准确定义：')
        print('设G=(V,E)是一个流网络,其源点为s,汇点为t.设f是G的一个前置流.如果函数h:V->N满足h(s)=|V|,h(t)=0',
            '且对每条残留边(u,v)∈Ef,有h(u)<=h(v)+1,则该函数为高度函数')
        print('设G=(V,E)是一个网络流,其源点为s,汇点为t.设f是G的一个前置流.h是定义在V上的高度函数',
            '对任意两顶点u`,v∈V,如果h(u)>h(v)+1,则(u,v)不是残留图中的边')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

class Chapter26_5:
    '''
    chpater26.5 note and function
    '''
    def note(self):
        '''
        Summary
        ====
        Print chapter26.5 note

        Example
        ====
        ```python
        Chapter26_5().note()
        ```
        '''
        print('chapter26.5 note as follow')  
        # python src/chapter26/chapter26note.py
        # python3 src/chapter26/chapter26note.py

chapter26_1 = Chapter26_1()
chapter26_2 = Chapter26_2()
chapter26_3 = Chapter26_3()
chapter26_4 = Chapter26_4()
chapter26_5 = Chapter26_5()

def printchapter26note():
    '''
    print chapter26 note.
    '''
    print('Run main : single chapter twenty-six!')  
    chapter26_1.note()
    chapter26_2.note()
    chapter26_3.note()
    chapter26_4.note()
    chapter26_5.note()

# python src/chapter26/chapter26note.py
# python3 src/chapter26/chapter26note.py
if __name__ == '__main__':  
    printchapter26note()
else:
    pass
