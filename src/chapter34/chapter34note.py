# coding:utf-8
# usr/bin/python3
# python src/chapter34/chapter34note.py
# python3 src/chapter34/chapter34note.py
"""

Class Chapter34_1

Class Chapter34_2

Class Chapter34_3

Class Chapter34_4

Class Chapter34_5

"""
from __future__ import absolute_import, division, print_function

if __name__ == '__main__':
    pass
else:
    pass

class Chapter34_1:
    """
    chapter34.1 note and function
    """
    def __init__(self):
        pass

    def note(self):
        """
        Summary
        ====
        Print chapter34.1 note

        Example
        ====
        ```python
        Chapter34_1().note()
        ```
        """
        print('chapter34.1 note as follow')
        print('第34章 NP完全性')
        print('之前学习过的算法都是多项式时间算法:对规模为n的输入,它们在最坏情况下的运行时间为O(n^k),其中k为某个常数',
            '但是不是所有的问题都能在多项式时间内解决.例如图灵著名的“停机问题”,任何计算机不论耗费多少时间也不能解决')
        print('还有一些问题是可以解决的,但对任意常数k,都不能在O(n^k)的时间内得到解答.')
        print('一般来说,把可以由多项式时间的算法解决的问题看作是易处理的问题,而把需要超多项式时间才能解决的问题看作是难处理的问题')
        print('本章的主题是一类称为“NP完全”(NP-complete)的有趣问题,它的状态是未知的.直到现在,既没有人找出求解NP完全问题的多项式算法,',
            '也没有人能够证明对这类问题不存在多项式时间算法')
        print('这一所谓的P!=NP问题自1971年被提出之后,已经成为了理论计算机科学研究领域中,最深奥和最错综复杂的开放问题之一了')
        print('NP完全问题有一个方面特别诱人,就是在这一类问题中,有几个问题在表面上看来与有着多项式时间算法的问题非常相似',
            '在下面列出的每一对问题中,一个是可以在多项式时间内求解的,另一个是NP完全的,但从表面上看,两个问题之间差别很小')
        print('最短与最长简单路径：在第24章中,即使是在有负权值边的情况下,也能在一个有向图G=(V,E)中,在O(VE)的时间内,从一个源顶点开始找出最短的路径',
            '然而,寻找两个顶点间最长简单路径是NP完全的.事实上,即使所有边的权值都是1,它也是NP完全的')
        print('欧拉游程与哈密顿回路：对一个连通的有向图G=(V,E)的欧拉游程是一个回路,它遍历图G中每条边一次',
            '但可能不止一次地访问同一个顶点,可以在O(E)时间内,确定一个图中是否存在一个欧拉游程,并且能在O(E)时间内找出这一欧拉游程中的各条边',
            '一个有向图G=(V,E)的哈密顿回路是一种简单回路,它包含V中的每个顶点。确定一个有向图或者无向图中是否存在哈密顿回路是NP完全的')
        print('NP完全性与P类和NP类')
        print('  三类问题：P,NP和NPC,其中最后一类指NP完全问题.此处只是非形式地对它们进行描述,后面将给出更为形式的定义')
        print('  P类中包含的是在多项式时间内可解的问题.更具体一点,都是一些可以在O(n^k)时间内求解的问题,此处k为某个常数,n是问题的输入规模',
            '前面大多数算法绝大部分都属于P类')
        print('  NP类中包含的是在多项式时间内“可验证”的问题,此处是指某一解决方案的“证书”,就能够在问题输入规模的多项式时间内,验证该证书是正确的',
            '例如:在哈密顿回路问题中,给定一个有向图G=(V,E),证书可以是一个包含|V|个顶点的序列<v1,v2,v3,...,v|v|>',
            '很容易在多项式时间内判断出对i=1,2,3,...,|V|-1,是否有(vi,vi+1)∈E和(v|v|,v1)∈E')
        print('  P中的任何问题也都属于NP,这是因为如果某一问题是属于P的,则可以在不给出证书的情况下,在多项式时间内解决它.',
            '至于P是否是NP的一个真子集,在目前是一个开放的问题')
        print('  从非形式的意义上来说,如果一个问题属于NP,且与NP中的任何一个问题是一样“难的”(hard),写说它属于NPC类,也称它为NP完全的')
        print('  同时,不加证明地宣称如果任何NP完全的问题可以在多项式时间内解决,则每一个NP完全的问题都有一个多项式时间的算法')
        print('  从表面上看,很多自然而有趣的问题并不比排序,图的搜索或网络流问题更困难,但事实上,它们却是NP完全问题')
        print('NP完全性证明有点类似于8.1节中任何比较排序算法的运行时间下界Ω(nlgn)的证明;',
            '但是用于证明NP完全性所用到的特殊技巧却和8.1节中的决策树方法是不同的')
        print('证明一个问题为NP完全问题时,要依赖于三个关键概念：')
        print('  (1) 判定问题与最优化问题')
        print('  很多有趣的问题都是最优化问题(optimization problem),其中每一种可能的解都有一个相关的值,我们的目标是找出一个具有最佳值的可行解',
            '例如,在一个称为SHORTEST-PATH,已知的是一个无向图G及顶点u和v,要找出u到v之间的经过最少边的路径',
            '(换句话说,SHORTEST-PATH是在一个无权、无向图中的单点对间最短路径问题),',
            '然而,NP完全性不直接适合于最优化问题,但适合于判定问题(decision problem)',
            '因为这种问题的答案是简单的“是(1)”或“否(0)”')
        print('  通常,通过对待优化的值强加一个界,就可以将一个给定的最优化问题转换为一个相关的判定问题了')
        print('  例如,对SHORTEST-PATH问题来说,它有一个相关性的判定问题(称其为PATH),就是要判定给定的有向图G,顶点u和v,一个整数k,在u和v之间是否存在一条包含至多k条边的路径')
        print('  试图证明最优化问题是一个“困难的”问题时,就可以利用该问题与相关的判定问题之间的关系.',
            '这是因为,从某种意义上来说,判定问题要“更容易一些”,或至少“不会更难”')
        print('  例如,可以先解决SHORTEST-PATH问题,再将找出的最短路径上边的数目与相关判定问题中参数k进行比较,从而可以解决PATH问题',
            '换句话说,如果某个最优化问题比较容易的话,那么其相关的判定问题也会是比较容易的')
        print('  (2) 归约')
        print('  上述有关证明一个问题不难于或不简单于另一个问题的说法,对两个问题都是判定问题也是适用的',
            '在几乎每一个NP完全性证明中,都利用了这一思想.做法如下:考虑一个判定问题(称为A),希望在多项式时间内解决该问题.',
            '称某一特定问题的输入为该问题的一个实例,例如,PATH问题的一个实例可以是某一特定的图G、G中特定的点u和v和一个特定的整数k',
            '现在,假设有另一个不同的判定问题(称为问题B),知道如何在多项式时间内解决它.假设有一个过程,能将A的任何实例a转换成B的、具有以下特征的某个实例b:')
        print('  1) 转换操作需要多项式时间;')
        print('  2) 两个实例的答案是相同的.亦即,a的答案是“是”,当且仅当b的答案也是“是”')
        print('  称这样的一种过程为多项式时间的归约算法(reduction algorithm),并且提供了一种在多项式时间内解决问题A的方法:')
        print('  1) 给定问题A的一个实例a,利用多项式归约算法,将它转换为问题B的一个实例b')
        print('  2) 在实例b上,运行B的多项式时间判定算法')
        print('  3) 将b的答案用作a的答案')
        print('  只要上述步骤中的每一步只需多项式时间,则所有三步合起来也只需要多项式时间,这样就有了一种对a进行判断的方法')
        print('  换句话说,通过将对问题A的求解“归约”为对问题B的求解,就可以利用B的“易求解性”来证明A的“易求解性”')
        print('NP完全性是为了反映一个问题有多难,而不是为了反映它是多么容易.',
            '因此,以相反的方式来利用多项式时间归约,从而说明某一问题是NP完全的')
        print('至于NP完全性,不能假设问题A绝对没有多项式时间的算法,然而,证明的方法是类似的,即假设问题A是NP完全的前提下,来证明问题B是NP完全的')
        print('第一个NP完全问题')
        print('  应用归约技术要有一个前提,即已知一个NP完全的问题,这样才能证明另一个问题也是NP完全的.',
            '因此,需要找到一个“第一个NP完全问题”.将使用的这一个问题就是电路可满足性问题')
        print('  在这个问题中,已知的是一个布尔组合电路,它由AND、OR和NOT门组成,希望知道这个电路是否存在一组布尔输入,能够使它的输出为1')
        print('34.1 多项式时间')
        print('多项式时间可解问题的形式化定义')
        print('  (1) 把所需运行时间Θ(n^100)的问题作为难处理问题的合理之处,但在实际中,需要如此高次的多项式时间的问题是非常少的',
            '在实际中,所遇到的典型多项式时间可解问题所需的时间要少的多.经验表明：一旦某一问题的一个多项式时间算法被发现后,',
            '往往就会发现一些更为有效的算法,即使对某个问题来说,当前最佳算法的运行时间为Θ(n^100),很有可能在很短的时间内',
            '就能找到一个运行时间要好的多的算法')
        # !串行随机存取计算机模型
        print('  (2) 对很多合理的计算模型来说,在一个模型上用多项式时间可解的问题,在另一个模型上也可以在多项式时间内获得解决',
            '例如,在串行随机存取计算机模型上多项式可求解的问题类,与抽象的图灵机上在多项式时间内可求解的问题类是相同的,',
            '它也与利用并行计算机在多项式时间内可求解的问题类相同,即使处理器数目随输入规模以多项式增加也是这样')
        print('  (3) 多项式时间可解问题问题类具有很好的封闭性,这是因为在加法、乘法和组合运算下,多项式是封闭的.',
            '例如,如果一个多项式时间算法的输出馈送给另一个多项式时间算法作为输入,则得到的组合算法也是多项式时间的算法',
            '如果另外一个多项式时间算法对一个多项式时间的子程序进行常数次调用,那么组合算法的运行时间也是多项式的')
        print('抽象问题')
        print('  抽象问题Q为在问题实例集合I和问题解法集合S上的一个二元关系.例如,SHORTEST-PATH的一个实例是由一个图和两个顶点所组成的三元组,',
            '其解为图中的顶点序列,序列可能为空,表示两个顶点间不存在通路.问题SHORTEST-PATH本身就是一个关系,',
            '把图的每个实例和两个顶点与图中联系这两个顶点的最短路径联系在了一起.因为最短路径不一定是唯一的.',
            '因此,一个给定问题实例可能有多个解')
        print('编码')
        print('  如果要用一个计算机程序求解一个抽象问题,就必须用一种程序能理解的方式来表示问题实例.')
        print('  抽象对象集合S的编码是从S到二进制串集合的映射e.例如,都熟悉把自然数N={0,1,2,3,4,...}编码为{0,1,10,11,100,101,...}',
            '如bin(17)=10001')
        print(' ASCII编码、EBCDIC编码、UNICODE编码')
        print('多边形、图、函数、有序对、程序等所有这些都可以编码为二进制串')
        print('因此,“求解”某个抽象判定问题的计算机算法实际上把一个问题实例我的编码作为其输入.',
            '把实例集为二进制串的集合的问题称为具体问题.当提供给一个算法的是长度n=|i|的一个问题实例i时,算法可以在O(T(n))时间内产生问题的解,',
            '就说该算法在时间O(T(n))内解决了该具体问题。')
        print('因此，如果对某个常数k，存在一个算法能在时间O(n^k)内求解出某具体问题,就说该具体问题是多项式时间可解的')
        print('根据编码的不同,算法的运行时间可以是多项式时间或超多项式时间')
        print('如果不先指定编码,就不可能真正谈及对一个抽象的问题求解.在实际中,如果不采用“代价高昂的”编码(一元编码)',
            '则问题的实际编码形式对问题是否能在多项式时间内求解是微不足道的',
            '例如,以3代替2为基数来表示整数,对问题是否能在多项式时间内求解没有任何影响,',
            '因为可以在多项式时间内,将以3表示的整数可以转换为以基数2表示的整数')
        print('对一个抽象问题的实例,采用二进制或三进制来进行编码,对其“复杂性”都没有影响')
        print('引理34.1 设Q是定义在一个实例集I上的一个抽象判定问题,e1和e2是I上多项式相关的编码,则e1(Q)∈P当且仅当e2(Q)∈P')
        print('只要隐式地使用与标准编码多项式相关的编码,就可以直接讨论抽象问题,而无需参照任何特定的编码',
            '因为已经知道选取哪一种编码对该问题是否多项式时间可解没有任何影响')
        print('形式语言体系')
        print('  判定问题PATH对应的语言为')
        print('  PATH={<G,u,v,k>：G=(V,E)是一个无向图,u,v∈V,k>=0是一个整数,图G中从u到v存在一条长度至多为k的路径}')
        print('  形式语言体系可以用来表述判定问题与求解这些问题的算法之间的关系.如果对给定输入x,算法输出A(x)=1,就说算法A接受串x∈{0,1}.',
            '被算法A接受的语言是串的集合L={x∈{0,1}*:A(x)=1},即为算法所接受的串的集合。如果A(x)=0,则说算法A拒绝串x')
        print('  例如,语言PATH就能够多项式时间内被接受.一个多项式时间的接受算法要验证G是否编码一个无向图G,u和v是否是G中的顶点,',
            '利用广度优先搜索计算出G中从u到v的最短路径,然后把得到的最短路径上边数与k进行比较',
            '如果G编码了无向图,且从u到v的路径中至多有k条边,则算法输出1并停机;否则,该算法永远运行下去',
            '但是这一算法并没有对PATH问题进行判定,因为对最短路径长度多余k条边的实例,算法并没有显示地输出0',
            'PATH的判定算法必须显式地拒绝不属于PATH的二进制串.',
            '对PATH这样的判定问题来说,很容易设计出这样的一种判定算法：当不存在从u到v的、包含至多k条边的路径时,算法不是永远的运行下去,',
            '而是输出0并停机.对于其他的一些问题(如图灵停机问题),只存在接受算法,而不存在判定算法')
        print('可以非形式地定义一个复杂性类(complexity class)为语言的一个集合,某一语言是否属于该集合,可以通过某种复杂性度量(complexity measure)来确定',
            '比如一个算法的运行时间,该算法可以确定某个给定的串x是否属于语言L.',
            '复杂性类的实际定义要更专业一些')
        print('运用上述的形式语言理论体系,可以提出关于复杂性类P的另外一种定义:')
        print(' P∈{L∈{0,1}*：存在一个算法A能在多项式时间内判定L}.事实上,P也是能在多项式时间内被接受的语言类')
        print('定理34.2 P={L：L能被一个多项式时间的算法所接受}')
        print('练习34.1-1 定义最优化问题LONGEST-PATH-LENGTH为一个关系,它将一个无向图的每个实例、两个顶点与这两个顶点间最长路径中所包含的边数联系了起来',
            '定义判定问题LONGEST-PATH={<G,u,v,k>:G=(V,E)为一个无向图,u,v∈V,k>=0是一个整数,且G中存在着一条从u到v的简单路径,它包含了至少k条边}.',
            '证明最优问题LONGEST-PATH-LENGTH可以在多项式时间内解决,当且仅当LONGEST-PATH∈P')
        print('练习34.1-2 对于在无向图中寻找最长简单回路这一问题,给出其形式化的定义及相关的判定问题.另外,给出与该判定问题对应的语言')
        print('练习34.1-3 给出一种形式化的编码,利用邻接矩阵表示形式,将有向图编码为二进制串.另外再给出利用邻接表表示的编码.论证这两种表示是多项式时间相关的')
        print('练习34.1-4 0-1背包问题的动态规划算法是一个多项式时间算法')
        print('练习34.1-5 证明:对于一个多项式时间算法,当它调用一个多项式时间的子例程时,如果至多调用常数次,则此算法以多项式时间运行',
            '但是,当调用子例程的次数为多项式时,此算法就可能变成一个指数时间的算法')
        print('练习34.1-6 类P在被看作是一个语言集合时,在并集、交集、补集和Kleene星运算下是封闭的.',
            '亦即,如果L1,L2∈P,则L1∪L2∈P,等等.')
        # python src/chapter34/chapter34note.py
        # python3 src/chapter34/chapter34note.py

class Chapter34_2:
    """
    chapter34.2 note and function
    """
    def __init__(self):
        pass

    def note(self):
        """
        Summary
        ====
        Print chapter34.2 note

        Example
        ====
        ```python
        Chapter34_2().note()
        ```
        """
        print('chapter34.2 note as follow')
        print('34.2 多项式时间的验证')
        print('对语言成员进行“验证”的算法.假如对判定问题PATH的一个给定实例<G,u,v,k>,同时也给定了一条从u到v的路径p.',
            '可以检查p的长度是否至多为k.如果是的,就可以把p看作是该实例的确属于PATH的“证书”.对于判定问题PATH来说,',
            '这一证书没有使我们得益多少.事实上,PATH可以在线性时间内求解')
        print('因此,根据指定的整数来验证成员所需的时间与从头开始解决问题的时间一样长')
        print('哈密顿回路')
        print('在无向图找出哈密顿回路这一问题已经被研究100多年了.形式地说,无向图G=(V,E)中的一个哈密顿回路是通过V中每个顶点一次的简单回路',
            '具有这种回路的图称为哈密顿图,否则称为非哈密顿图')
        print('定义哈密顿回路问题的形式语言：“图G中是否具有一条哈密顿回路”')
        print('HAM-CYCLE={<G>:G是一个哈密顿图}')
        print('已知一个哈密顿回路问题<G>,一种可能的判定算法就是罗列出G的顶点的所有排列,然后对每一种排列进行检查,以确定它是否是一条哈密顿回路',
            '如果我们“合理地”把图编码为邻接矩阵,图中顶点数m为Ω(sqrt(n)),其中n=|<G>|是G的编码长度,则总共会有m!种可能的顶点排列,',
            '因此,算法的运行时间为Ω(m!)=Ω(sqrt(n)!)=Ω(2^sqrt(n)),它并非是O(n^k)的形式(k为任意常数).',
            '因此这种朴素算法的运行时间并不是多项式时间.事实上,哈密顿问题是NP完全的问题')
        print('验证算法')
        print('  假设某给定图G是哈密顿图,并提出可以通过给出沿哈密段回路排列的顶点来证明他的话.证明当然是非常容易的:',
            '仅仅需要检查所提供的回路是否是V中顶点的一个排列,以及沿回路的每条连接的边是否在图中存在,这样就可以验证所提供的回路是否是哈密顿回路',
            '当然,该验证算法可以在O(n^2)的时间内实现,其中n是G的编码的长度',
            '因此,我们可以在多项式时间内验证图中存在一条哈密顿回路和证明过程')
        print('  例如,在哈密顿回路问题中,证书是哈密顿中顶点的列表.如果一个图是哈密顿图,哈密顿回路本身就提供了足够的信息来验证这一事实',
            '相反地,如果某个图不是哈密顿图,那么也不存在这样的顶点列表能使验证算法认为该图是哈密顿图',
            '因为验证算法会会仔细地检查所提供的“回路”是否不是哈密顿回路')
        print('复杂类NP')
        print('  复杂类NP是能被一个多项式时间算法验证的语言类.更准确地说,一个语言L属于NP,当且仅当存在一两个输入的多项式算法A和常数c满足:',
            'L={x∈{0,1}*:存在一个证书y(|y|=O(|x|^c))满足A(x,y)=1}','说算法A在多项式时间内验证了语言L')
        print('  根据先前对哈密顿回路问题的讨论,可知HAM-CYCLE∈NP.此外,如果L∈P,则L∈NP.',
            '如果存在一个多项式时间的算法来判定L,那么只要忽略任何证书,并接受那些它确定属于L的输入串,就可以很容易地把该算法转化为一个两参数的验证算法.因此P∈NP')
        print('目前还不知道是否有P=NP,但大多数研究人员认为P和NP不是同一个类')
        print('从直觉上看,类P由可以很快解决的问题组成,而类NP由可以很快验证其解的问题组成.')
        print('在P!=NP问题之外,还有许多其他基本问题没有解决,尽管很多研究人员做了大量的工作,但还没有人知道NP类在补运算下是否是封闭的',
            '亦即,L∈NP是否说明了L∈NP的语言L的集合')
        print('可以定义复杂类co-NP为满足L∈NP的语言L构成的集合.这样一来,NP在补运算下是否封闭的问题就可以重新表示为是否有NP=co-NP')
        print('练习34.2-1 考虑语言GRAPH-ISOMOPRHISM={<G1,G2>:G1和G2是同构图}.通过描述一个可以在多项式时间内验证该语言的算法',
            '来证明GRAPH-ISOMOPRHISM∈NP')
        print('练习34.2-2 证明:如果G是一个无向的二分图,且有着奇数个顶点,则G是非哈密顿图')
        print('练习34.2-3 证明:如果HAM-CYCLE∈P,则按序列出一个哈密顿回路中的各个顶点的问题是多项式时间可解的')
        print('练习34.2-4 证明:由语言构成的NP类在并集、交集、并置和Kleene星运算下是封闭的')
        print('练习34.2-5 证明:NP中的任何语言都可以用一个运行时间为2^O(n^k)(其中k为常数)的算法来加以判定')
        print('练习34.2-6 图中的哈密顿路径是一种简单路径,经过图中每个顶点一次.证明:语言HAM-PATH={<G,u,v>:图G中存在}')
        print('练习34.2-7 证明：在有向无回路中,哈密顿路径问题可以在多项式时间内求解.给出解决该问题的一个有效算法')
        print('练习34.2-8 设p为一个布尔公式,它由布尔输入变量x1,x2,...,xk,非(~)、AND(∧)、OR(∨)和括号组成.',
            '如果对公式p的输入变量的每一种1和0赋值,公式的结果都为1,则称其为重言式.',
            '定义TAUTOLOGY为由重言布尔公式所组成的语言.证明:TAUTOLOGY∈co-NP')
        print('练习34.2-9 证明P∈co-NP')
        print('练习34.2-10 证明:如果NP!=co-NP,则P!=NP')
        print('练习34.2-11 设G为一个包含至少3个顶点的连通无向图,并设对G中所有由长度至多为3的路径连接起来的点对',
            '将它们直接连接后所形成的图为G^3.证明:G^3是一个哈密顿图.(提示:为G构造一棵生成树,并采用归纳法进行证明)')
        # python src/chapter34/chapter34note.py
        # python3 src/chapter34/chapter34note.py

class Chapter34_3:
    """
    chapter34.3 note and function
    """
    def __init__(self):
        pass

    def note(self):
        """
        Summary
        ====
        Print chapter34.3 note

        Example
        ====
        ```python
        Chapter34_3().note()
        ```
        """
        print('chapter34.3 note as follow')
        print('34.3 NP完全性与可归约性')
        print('从事理论研究的计算机科学家们之所以会相信P!=NP,最令人信服的理由可能就是存在着一类“NP完全”问题,该类问题有一种令人惊奇的性质,',
            '即如果一个NP完全问题能在多项式时间内得到解决,那么,NP中的每一个问题都可以在多项式时间内求解')
        print('即P=NP.但是,尽管进行了多年的研究,目前还没有找出关于任何NP完全性问题的多项式时间的算法')
        print('语言HAM-CYCLE就是一个NP完全问题.如果能够在多项式时间内判定HAM-CYCLE,就能够在多项式时间求解NP中的每一个问题.',
            '事实上,如果能证明NP-P为非空集合,就可以肯定地说HAM-CYCLE∈NP-P')
        print('在某种意义上说,NP完全语言是NP中“最难”的语言.在本节中,要说明如何运用称为“多项式时间可归约性”的确切概念,来比较各种语言的相对“难度”')
        print('一个问题Q可以被归约为另一个问题Q\',如果Q的任何实例都可以被“容易地重新描述为Q\'的实例”')
        print('例如,求解关于未知量x的线性方程问题可以转化为求解二次方程问题.已知一个实例ax+b=0',
            '可以把它变换为0x^2+ax+b=0,其解也是方程ax+b=0的解.因此,如果一个问题Q可以转化为另一个问题Q\'',
            '则从某种意义上来说,Q并不比Q\'更难解决')
        print('关于判定问题的形式语言体系,说语言L1在多项式时间内可以归约为语言L2,写作L1<=pL2,',
            '如果存在一个多项式时间可计算的函数f:{0,1}*->{0,1}*,满足对所有的x∈{0,1}*,都有:',
            'x∈L1当且仅当f(x)∈L2.称函数f为归约函数,计算f的多项式时间算法F称为归约算法')
        print('关于从语言L1到另一种语言L2的多项式时间归约的思想.每一种语言都是{0,1}*的子集,归约函数f提供了一个多项式时间的映射,',
            '使得如果x∈L1,则f(x)=L2.如果x∉L1,则f(x)∉L2.因此,归约函数提供了从语言L1表示的判定问题的任意实例x到语言L2表示的判定问题的实例f(x)上映射',
            '如果能提供是否有f(x)∈L2的答案,也就直接提供了是否有x∈L1的答案')
        print('引理34.3 如果L1、L2∈{0,1}*是满足L1<=pL2的语言,则L2∈P蕴含着L1∈P.')
        print('NP完全性')
        print('多项式时间归约提供了一种形式方法,用来证明一个问题在一个多项式时间因子内至少与另一个问题一样难.',
            '亦即,如果L1<=pL2,则L1大于L2的难度不会超过一个多项式时间因子,这就是采用“小于或等于”来表示归约记号的原因')
        print('NP完全语言集合的定义')
        print('语言L∈{0,1}*是NP完全的,如果')
        print('1.L∈NP')
        print('2.对每一个L‘∈NP,有L‘<=pL')
        print('如果一种语言L满足性质2,但不一定满足性质1,则称L是NP难度(NP-hard)的,定义NPC为NP完全语言类')
        print('定理34.4 (NP完全性是判定P是否等于NP的关键) 如果任何NP完全问题是多项式时间可求解的,则P=NP.',
            '等价地,如果NP中的任何问题不是多项式时间可求解的,则所有NP完全问题都不是多项式可求解的')
        print('电路可满足性问题')
        print('  一旦证明了至少有一个问题是NP完全问题,就可以用多项式时间可归约性作为工具,来证明其他问题也具有NP完全性.',
            '下面证明一个NP完全问题:电路可满足性问题')
        print('  布尔组合电路是由布尔组合元素通过电路互连后构造而成的.布尔组合元素是指任何一种电路元素,有着固定数目的输入和输出',
            '执行的是某种良定义的函数功能.布尔值取自集合{0,1},其中0代表FALSE(假),1代表TRUE(真)')
        print('  在电路可满足性问题中,所用到的布尔组合元素计算的是一个简单的布尔函数,这些元素称为逻辑门(组合逻辑电路)')
        print('  三种基本的逻辑门:NOT门(非门,反相器),AND门(与门),OR门(或门).NOT门只有一个二进制输入x,它的值为0或1,产生的是二进制输出z',
            '其值与输入值相反.另外两种门都取两个二进制输入x和y,产生一个二进制输出z')
        print('  用∧来表示AND函数,用∨来表示OR函数.例如0∨1=1,实际的硬件设计中,布尔组合电路可以有多个输出')
        print('  布尔组合电路不包含回路.假设创建了一个有向图G=(V,E),其中每个顶点代表一个组合元素,k条有向边代表每一根扇出为k的接线;',
            '如果某一接线将一个元素u的输出与另一个元素v的输入连接了起来,图中就会有一条有向边(u,v).那么G必定是无回路的')
        print('  电路可满足性问题定义:给定一个由与、或和非门构成的一个布尔组合电路,它是可满足电路吗?',
            '为了给出这一问题的形式定义,必须对电路的编码有一个统一的标准.布尔组合电路的规模是指其中布尔组合元素的个数,',
            '再加上电路中接线的数目.可以设计出一种像图形那样的编码,使其可以把任何给定电路C映射为一个二进制串<C>,',
            '该串的长度与电路本身的规模呈多项式关系.于是定义CIRCUIT-SAT={<C>:C是一个可满足的布尔组合电路}')
        print('  电路可满足性问题在计算机辅助硬件优化领域中极其重要.如果一个子电路总是输出0,就可以用一个更为简单的子电路来取代原电路',
            '该子电路省略了所有的逻辑门,并提供常数值0作为其输出.如果能够开发关于该问题的多项式时间算法,那将具有很大的实际应用价值')
        print('  给定一个电路C,通过检查输入的所有可能赋值来确定它是否是可满足性电路,但如果有k个输入,就会有2^k种可能的赋值.',
            '当电路C的规模为k的多项式时,对每个电路进行检查需要Ω(2^k)的时间,这与电路的规模呈超多项式关系')
        print('  有很强的证据表明:不存在能解决电路可满足性问题的多项式时间算法,因为该问题是NP完全的.根据NP完全性定义中的两个部分,把对这一事实的证明过程也分为两部分')
        print('引理34.5 电路可满足性问题属于NP类')
        print('引理34.6 电路可满足性问题是NP难度的')
        print('定理34.7 电路可满足性问题是NP完全的')
        print('练习34.3-1 略')
        print('练习34.3-2 证明: <=p关系时语言上的一种传递关系.亦即,要证明如果有L1<=pL2,且L2<=pL3,则有L1<=pL3')
        print('练习34.3-3 证明：L<=pL’,当且仅当L’<=pL')
        print('练习34.3-4 证明：在对引理34.5的另一种证明中,可满足性赋值可以当做证书来使用.哪一个证书可以使证明过程更容易些')
        print('练习34.3-5 在引理34.6的证明中,假定算法A的工作存储占用的是一片具有多项式大小的连续存储空间.',
            '在该证明中的什么地方用到了这一假设?论证这一假设是不失一般性的')
        print('练习34.3-6 相对于多项式时间的归约来说,一个语言L对语言类C是完全的,如果对所有L‘∈C,有L∈C.证明:相对于多项式时间的归约来说,',
            'phi和{0,1}*是P中仅有的对P不完全的语言.')
        print('练习34.3-7 证明：L对NP是完全的,当且仅当L’对co-NP是完全的')
        print('练习34.3-8 归约算法F基于有关x、A和k的信息,构造了电路C=f(x).',
            'Sartre教授观察到串x是F的输入,但只有A、k的存在性和运行时间O(n^k)中所隐含的常数因子对F来说是已知的(因为语言L属于NP)',
            '但实际值对F来说却是未知的','因此,这位教授就得出了这样的结论,即F不可能构造出电路C,且语言CIRCUIT-SAT不一定是NP难度的')
        # python src/chapter34/chapter34note.py
        # python3 src/chapter34/chapter34note.py

class Chapter34_4:
    """
    chapter34.4 note and function
    """
    def __init__(self):
        pass

    def note(self):
        """
        Summary
        ====
        Print chapter34.4 note

        Example
        ====
        ```python
        Chapter34_4().note()
        ```
        """
        print('chapter34.4 note as follow')
        print('34.4 NP完全性的证明')
        print('电路可满足性问题的NP完全性依赖于直接证明对每一种语言L∈NP,有L<=pCIRCUIT-SAT.本节中将说明,',
            '如何在不把NP中的每一种语言直接归约为给定语言的前提下,证明一种语言是NP完全的.')
        print('引理34.8 如果L是一种满足对某个L’∈NPC,有L’<=pL,则L是NP难度的.此外,如果L∈NP,则L∈NPC')
        print('换句话说,通过把一个已知为NP完全的语言L’归约为L,就可以把NP中的每一种语言都隐式地归约为L.')
        print(' 1) 证明L∈NP')
        print(' 2) 选取一个已知的NP完全语言L’')
        print(' 3) 描述一种算法来计算一个函数f,把L’中的每个实例x∈{0,1}*都映射为L中的一个实例f(x)')
        print(' 4) 证明对所有x∈{0,1}*,函数f满足x∈L’当且仅当f(x)∈L')
        print(' 5) 证明计算函数f的算法具有多项式运行时间')
        print('公式可满足性')
        print('  对于确定布尔公式(而不是电路)是否可满足这一问题,通过给出一个NP完全性证明,来说明上面提到的归约方法.在算法历史上,',
            '这个问题是第一个被证明为NP完全的')
        print('  (公式)可满足性问题可以根据语言SAT描述如下:SAT的一个实例就是一个由下列成分组成的布尔公式p')
        print('  1.n个布尔变量:x1,x2,...,xn')
        print('  2.m个布尔连接词：布尔连接词是任何具有一个或两个输入和一个输出的布尔函数,',
            '如∧(与),∨(或),~(非),->(蕴含),<->(当且仅当)')
        print('  3.括号.(不失一般性,假定没有冗余的括号;亦即,每个布尔连接词至多有一对括号)')
        print('  很容易对一个布尔公式p进行编码,使其长度为n+m的多项式.如在布尔组合电路中一样,环宇一个布尔公式p的真值赋值是为p中各变量所取的一组值;',
            '可满足性赋值是指使公式p的值为1的真值赋值.具有可满足性赋值的董事就是可满足公式.形式语言:',
            'SAT={<p>:p是一个可满足布尔公式}')
        print('  例如公式((x1->x2)∨~((~x1<->x3)∨x4))∧~x2,具有可满足性赋值<x1=0,x2=0,x3=1,x4=1>',
            '这是因为((0->0)∨~((~0<->1)∨1))∧~0=(1∨~(1∨1))∧1=(1∨0)∧1=1,因此,该公式p属于SAT')
        print('  确定一个任意的布尔公式是否是可满足的朴素算法不具有多项式运行时间.在一个具有n个变量的公式p中,有2^n种可能的赋值.',
            '如果<p>的长度是关于n的多项式,则检查每一种可能的赋值需要Ω(2^n)时间,这是<p>长度的一个超多项式')
        print('定理34.9 布尔公式的可满足性问题是NP完全的')
        print('  证明:首先论证SAT∈NP,然后通过证明CIRCUIT-SAT<=pSAT,来证明CIRCUIT-SAT是NP难度的;根据引理34.8可知,这将证明定理成立')
        print('3-CNF可满足性')
        print('  根据公式可满足性进行归约,可以证明很多问题是NP完全问题.归约算法必须能够处理任何输入公式,但这样一来,就必须考虑大量的情况.',
            '因此,常常需要根据布尔公式的一种限制性语言来进行归约,使需要考虑的情况较少')
        print('  当然,不能由于对该语言的限制过多,而使其成为多项式时间可解的语言.3-CNF可满足性(或3-CNF-SAT)就是这样一种方便的语言.')
        print('运用下列术语来定义3-CNF可满足性.布尔公式中的一个文字(literal)是指一个变量或变量的“非”.',
            '如果一个布尔公式可以表示为所有子句(clause)的“与”,且每个子句都是一个或多个文字的“或”,',
            '则称该布尔公式为合取范式,或CNF(conjunctive normal form).如果公式中每个子句恰好都有三个不同的文字,则称该布尔公式为3合取范式,或3-CNF')
        print('例如,布尔公式(x1∨~x1∨~x2)∧(x3∨x2∨x4)∧(~x1∨~x3∨~x4)就是一个3合取范式,其三个子句中的第一个为(x1∨~x1∨~x2),它包含三个文字x1,~x1和~x2')
        print('在3-CNF-SAT中,有这样的问题:3-CNF形式的一个给定布尔公式p是否满足?下列定理说明,即便当布尔公式表述为这种简单范式时,也不可能在多项式时间的算法以确定其满足性')
        print('定理34.10 3合取范式形式的布尔公式的可满足性问题是NP完全的')
        print('归约算法可以分为三个基本步骤.每一步骤都逐渐使输入公式p向所要求的3合取范式接近')
        print('第一步类似于在定理34.9中用于证明CIRCUIT-SAT<=pSAT的过程.首先,为输入公式p构造一棵二叉树“语法分析”树,连接词作为内部顶点:',
            'p=(x1->x2)∨~(~(x1<->x3)∨x4))∧~x2的一棵语法分析树.如果输入公式中有包含数个文字的“或”的子句,就可以利用结合律对表达式加上括号,',
            '以使在所产生的树中的每一个内部顶点上均有1个或两个子女.现在,就可以吧二叉语法分析树看作是计算该函数的一个电路')
        print('归约的第二步是把每个子句p‘i变换为合取范式.通过对p’i中变量的所有可能的赋值进行计算,可以构造出p’i的真值表.',
            '真值表中的每一行由子句变量的一种可能的赋值和根据这一赋值所计算出来的子句的值所组成.',
            '如果运用真值表中值为0的项,就可以构造出公式的析取范式(dissjunctive normal form, DNF),就是“与”的“或”',
            '它等价于~p‘i.然后运用摩根定律并把“或”变成“与”、“与”变成“或”,就可以把公式变换为CNF公式p‘’i')
        print('归约的第三步(也是最后一步)就是继续对公式进行变换,使每个子句恰好有三个不同的文字.',
            '最后的3-CNF公式p’‘’是根据CNF公式p’‘的子句构造出来的,其中使用了两个辅助变量p和q.对p’‘中的每个子句Ci,使p’‘’中包含下列子句')
        print('练习34.4-1 考虑一下在定理34.9的证明中的直接(非多项式时间)归约.描述一个规模为n的电路,当用这种归约方法将其转换为一个公式时,',
            '能产生出一个规模为n的指数的公式') 
        print('练习34.4-2 给出将定理34.10中的方法用于公式(34.3)时所得到的3-CNF公式')
        print('练习34.4-3 Jagger教授提出,在定理34.10的证明中,可以通过仅利用真值表技术(无需其他步骤),就能证明SAT<=p3-CNF-SAT.',
            '亦即,这位教授的意思是取布尔公式p,形成有关其变量的真值表,根据该真值表导出一个3-DNF形式的、等价于~p的公式,',
            '再对其取反,并运用摩根定律,从而可以得到一个等价于p的3-CNF公式.证明:这一策略不能产生多项式时间的归约')
        print('练习34.4-4 证明：确定某一布尔公式是否是重言式这一问题对co-NP来说是完备的.')
        print('练习34.4-5 证明：确定析取范式形式的布尔公式的可满足性这一问题是多项式时间可解的')
        print('练习34.4-6 假设某人给出了一个判定公式可满足性的多项式时间算法.请说明如何利用这一算法在多项式时间内找出可满足性赋值')
        print('练习34.4-7 设2-CNF-SAT为CNF形式的、每个子句中恰有两个文字的可满足公式的集合.证明:2-CNF-SAT∈P.所给出的算法应尽可能地高效.',
            '(提示:注意x∨y与~x->y是等价的.将2-CNF-SAT归约为一个在有向图上高效可解的问题)')
        # python src/chapter34/chapter34note.py
        # python3 src/chapter34/chapter34note.py

class Chapter34_5:
    """
    chapter34.5 note and function
    """
    def __init__(self):
        pass

    def note(self):
        """
        Summary
        ====
        Print chapter34.5 note

        Example
        ====
        ```python
        Chapter34_5().note()
        ```
        """
        print('chapter34.5 note as follow')
        print('34.5 NP完全问题')
        print('NP完全问题产生于各种不同领域:布尔逻辑,图论,算术,网络设计,集合与划分,存储于检索,排序与调度,数学程序设计,代数与数论,游戏与趣味难题',
            '自动机与语言理论,程序优化,生物学,化学,物理等等.本节将运用归约方法,对从图论到集合划分的各种问题进行NP完全证明')
        print('')
        print('')
        # python src/chapter34/chapter34note.py
        # python3 src/chapter34/chapter34note.py

chapter34_1 = Chapter34_1()
chapter34_2 = Chapter34_2()
chapter34_3 = Chapter34_3()
chapter34_4 = Chapter34_4()
chapter34_5 = Chapter34_5()

def printchapter34note():
    """
    print chapter34 note.
    """
    print('Run main : single chapter thirty-four!')
    chapter34_1.note()
    chapter34_2.note()
    chapter34_3.note()
    chapter34_4.note()
    chapter34_5.note()

# python src/chapter33/chapter33note.py
# python3 src/chapter33/chapter33note.py

if __name__ == '__main__':  
    printchapter34note()
else:
    pass
